{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"10_glossary.html","title":"Glossary","text":"<p>This glossary provides definitions for terms frequently used throughout this documentation.</p> <ul> <li>Interface: The user interface where natural language queries are entered.</li> <li>Orchestrator: The central system that manages task distribution and workflow coordination.</li> <li>Node: An individual AI agent within the Panacea network.</li> <li>Edge: The communication pathway between agents.</li> <li>Environment: The workspace allocated to each agent, containing necessary resources.</li> <li>Task: A specific instruction or piece of work assigned to an agent.</li> <li>Workflow: The complete sequence of tasks and processes managed by Panacea.</li> <li>Logging: The recording of agent activities and system operations for monitoring and analysis.</li> <li>API (Application Programming Interface): A set of protocols and tools for building software and applications.</li> <li>Multi-Agent System: A system composed of multiple interacting intelligent agents.</li> <li>Natural Language Processing (NLP): A field of AI focused on the interaction between computers and human language.</li> <li>Automation: The use of technology to perform tasks without human intervention.</li> <li>Scalability: The capability of a system to handle a growing amount of work by adding resources.</li> <li>Security: Measures taken to protect systems and data from unauthorized access or attacks.</li> <li>Compliance: Adherence to laws, regulations, and guidelines relevant to business processes.</li> <li>Deployment: The process of installing, configuring, and enabling a system to be operational.</li> <li>Agentic AI: AI systems designed to operate as autonomous agents, capable of making decisions and performing tasks independently.</li> <li>Centralized Logging: Aggregating logs from multiple sources into a single, unified system for easier management.</li> <li>Real-Time Monitoring: Continuously tracking system performance and agent activities as they occur.</li> <li>Audit Trail: A chronological record that provides documentary evidence of the sequence of activities that have affected a specific operation.</li> <li>Role-Based Access Control (RBAC): A method of restricting system access to authorized users based on their roles.</li> <li>Microservices Architecture: A design approach where a system is composed of small, independent services that communicate over well-defined APIs.</li> <li>Continuous Integration/Continuous Deployment (CI/CD): Practices that enable developers to integrate and deploy code changes frequently and reliably.</li> <li>Distributed Systems: Systems where components located on networked computers communicate and coordinate their actions by passing messages.</li> <li>Load Balancing: Distributing workloads across multiple computing resources to optimize resource use, maximize throughput, and minimize response time.</li> <li>Failover: The ability to switch automatically to a redundant or standby system upon the failure of the currently active system.</li> <li>High Availability (HA): Systems designed to operate continuously without failure for a long time.</li> <li>Elasticity: The ability of a system to dynamically acquire or release resources to adapt to changing workload demands.</li> </ul> <p></p>"},{"location":"11_autonomous_ai_coding_agent.html","title":"Autonomous AI Coding Agent","text":"<p>The Autonomous AI Coding Agent  is designed to streamline the software development process by autonmously analyzing an exisiting local codebase, generating and implementing a feature into the codebase, and then creating a pull request on a given github repo with the implemented changes. This agent collaborates with a group of specialized agents to handle the workflow efficiently.</p> <p></p>"},{"location":"11_autonomous_ai_coding_agent.html#key-features","title":"Key Features","text":"<ul> <li>Autonomous Feature Development: Identifies potential improvements and new features for a codebase without user intervention.</li> <li>Automated Workflow: Handles the end-to-end process, including coding, review, and implementation.</li> <li>GitHub Integration: Creates pull requests directly on the specified GitHub repository.</li> <li>Error Handling and Iterative Refinement: Continuously tests and improves the code until it meets quality standards.</li> </ul>"},{"location":"11_autonomous_ai_coding_agent.html#workflow-breakdown","title":"Workflow Breakdown","text":"<p>Let's go over a workflow where an AI agent autonomously identifies potential new features, writes the necessary code, integrates it into the codebase, and submits a pull request to the GitHub repository.</p> <ol> <li>Codebase Backup:</li> <li> <p>The user provides a GitHub access token and a github repository link. The AI creates a secure backup of the local codebase to ensure rollback options.</p> </li> <li> <p>Feature Identification:</p> </li> <li> <p>The Product Manager Agent analyzes the codebase and suggests potential new features.</p> </li> <li> <p>Feature Implementation:</p> </li> <li> <p>The Software Engineer Agent writes the code for the new feature.</p> </li> <li> <p>Code Review:</p> </li> <li> <p>The Code Reviewer Agent inspects the code for bugs, inefficiencies, and adherence to coding standards.</p> </li> <li> <p>Feature Integration:</p> </li> <li> <p>The Section Manager Agent integrates the new feature into the codebase.</p> </li> <li> <p>Testing and Deployment:</p> </li> <li>Tests the implemented feature to ensure functionality.</li> <li> <p>Creates a pull request on the specified GitHub repository.</p> </li> <li> <p>Backup Restoration:</p> </li> <li>Restores the original backup if errors arise during the process.</li> </ol>"},{"location":"11_autonomous_ai_coding_agent.html#example-use-case","title":"Example Use Case","text":""},{"location":"11_autonomous_ai_coding_agent.html#user-query","title":"User Query:","text":"<p>\"Analyze this codebase and implement a feature that tracks user activity and logs it into a database.\"</p>"},{"location":"11_autonomous_ai_coding_agent.html#teams-of-agents","title":"Teams of Agents","text":"<ol> <li>Product Manager Agent:</li> <li> <p>Identifies the need for user activity tracking and creates a task description.</p> </li> <li> <p>Software Engineer Agent:</p> </li> <li> <p>Writes the Python code to track user activity and log it to a database.</p> </li> <li> <p>Code Reviewer Agent:</p> </li> <li> <p>Validates the code for potential bugs, inefficiencies, and adherence to best practices.</p> </li> <li> <p>Section Manager Agent:</p> </li> <li>Integrates the new feature into the main codebase and creates a pull request.</li> </ol>"},{"location":"11_autonomous_ai_coding_agent.html#workflow","title":"Workflow","text":""},{"location":"11_autonomous_ai_coding_agent.html#step-1-initial-query","title":"Step 1: Initial Query","text":"<ul> <li> <p>User Query:   \"Create a Python script that scrapes data from a website, stores it in a CSV file, and optimizes the code for better performance.\"</p> </li> <li> <p>User Input:   Provides a GitHub access token and repository URL.</p> </li> </ul>"},{"location":"11_autonomous_ai_coding_agent.html#step-2-orchestrator-processing","title":"Step 2: Orchestrator Processing","text":"<ul> <li>The Orchestrator interprets the input and creates tasks:</li> <li>Analyze the codebase for new features.</li> <li>Implement the feature.</li> <li>Review, test, and deploy the feature.</li> </ul>"},{"location":"11_autonomous_ai_coding_agent.html#step-3-task-execution","title":"Step 3: Task Execution","text":"<ol> <li>Feature Analysis:</li> <li> <p>Product Manager Agent scans the codebase and identifies user activity tracking as a valuable addition.</p> </li> <li> <p>Feature Implementation:</p> </li> <li> <p>Software Engineer Agent writes a Python function to log user activity into a database or simulate such logging.</p> </li> <li> <p>Code Review:</p> </li> <li> <p>Code Reviewer Agent checks for vulnerabilities, syntax errors, and performance inefficiencies.</p> </li> <li> <p>Integration:</p> </li> <li>Section Manager Agent integrates the feature into the codebase and creates a pull request.</li> </ol>"},{"location":"11_autonomous_ai_coding_agent.html#step-4-testing-and-iteration","title":"Step 4: Testing and Iteration","text":"<ul> <li>Tests the feature for functionality and usability.</li> <li>If issues arise, tasks are reassigned to relevant agents for debugging and improvement.</li> </ul>"},{"location":"11_autonomous_ai_coding_agent.html#step-5-cycle-continues","title":"Step 5: Cycle Continues","text":"<ul> <li>The system iteratively improves the feature or script until it meets the desired performance and functionality standards.</li> </ul>"},{"location":"11_autonomous_ai_job_seeker_agent.html","title":"Job Seeker Agent","text":""},{"location":"11_autonomous_ai_job_seeker_agent.html#overview","title":"Overview","text":"<p>The Job Seeker Agent is tailored to assist individuals in automating their job search, application, and networking processes. By leveraging Panacea's multi-agent system, this agent streamlines the journey from identifying potential employers to securing job interviews.</p>"},{"location":"11_autonomous_ai_job_seeker_agent.html#scenario","title":"Scenario","text":"<p>User Query: Find all AI companies in New York, identify relevant job openings, and apply to these positions using my resume. Additionally, reach out to contacts within these companies to express my interest.</p>"},{"location":"11_autonomous_ai_job_seeker_agent.html#workflow-breakdown","title":"Workflow Breakdown","text":"<ol> <li>Query Interpretation by Orchestrator:</li> <li> <p>The Orchestrator analyzes the natural language query to discern the user's goals:</p> <ul> <li>Identifying AI companies in New York.</li> <li>Finding relevant job openings.</li> <li>Automating job applications.</li> <li>Networking with contacts within these companies.</li> </ul> </li> <li> <p>Task Definition and Assignment:</p> </li> <li>Task 1: Identify AI companies located in New York.<ul> <li>Assigned to: Web Surfer Agent</li> </ul> </li> <li>Task 2: Find job opportunities within these companies.<ul> <li>Assigned to: Job Searcher Agent</li> </ul> </li> <li>Task 3: Automate the job application process.<ul> <li>Assigned to: Autocode Agent</li> </ul> </li> <li> <p>Task 4: Network with contacts at these companies.</p> <ul> <li>Assigned to: Emailer Agent</li> </ul> </li> <li> <p>Agent Collaboration and Execution:</p> </li> </ol> <p>### Task 1: Company Identification    - Web Surfer Agent conducts targeted searches to compile a list of AI companies based in New York.    - It gathers essential details such as company name, size, website, and key contacts.</p> <p>### Task 2: Job Opportunity Discovery    - Job Searcher Agent explores each identified company's career page or job boards to find relevant job openings.    - It extracts information like job titles, descriptions, application deadlines, and requirements.</p> <p>### Task 3: Job Application Automation    - Autocode Agent utilizes the user's resume to apply for each identified position.      - Steps Involved:        - Resume Parsing: Extracts relevant information from the user's resume.        - Form Filling: Automatically fills out application forms with the parsed data.        - Submission: Submits the application to the respective job postings.</p> <p>### Task 4: Networking and Outreach    - Emailer Agent identifies key contacts within each company, such as hiring managers or team leads, by searching LinkedIn or company directories.    - It drafts and sends personalized outreach emails to these contacts to express interest and introduce the user's profile.      - Example Email: <pre><code>Subject: Interest in [Job Title] Position at [Company Name]\n\nHi [Contact Name],\n\nI recently applied for the [Job Title] position at [Company Name] and wanted to personally reach out to express my enthusiasm for the opportunity. With my background in [Your Field], I am excited about the prospect of contributing to your team.\n\nI would love to discuss how my skills and experiences align with your needs. Please let me know if you're available for a brief conversation.\n\nThank you for your time and consideration.\n\nBest regards,\n[Your Name]\n[Your LinkedIn Profile]\n[Your Contact Information]\n</code></pre></p> <ol> <li>Iterative Application and Networking:</li> <li>The Autonomous Iteration process ensures continuous application submissions and networking efforts.</li> <li>Agents monitor responses and schedule follow-up communications as necessary.</li> <li>The system adapts based on feedback, such as adjusting application strategies or refining email templates to improve engagement rates.</li> </ol>"},{"location":"11_autonomous_ai_job_seeker_agent.html#detailed-interaction-flow","title":"Detailed Interaction Flow","text":""},{"location":"11_autonomous_ai_job_seeker_agent.html#step-1-initial-query","title":"Step 1: Initial Query","text":"<ul> <li>User: \"Find all AI companies in New York, identify relevant job openings, and apply to these positions using my resume. Additionally, reach out to contacts within these companies to express my interest.\"</li> </ul>"},{"location":"11_autonomous_ai_job_seeker_agent.html#step-2-orchestrator-processing","title":"Step 2: Orchestrator Processing","text":"<ul> <li>Orchestrator:</li> <li>Parses the query to extract key tasks.</li> <li>Defines the workflow and assigns tasks to respective agents.</li> </ul>"},{"location":"11_autonomous_ai_job_seeker_agent.html#step-3-task-execution-by-agents","title":"Step 3: Task Execution by Agents","text":"<ul> <li>Web Surfer Agent:</li> <li>Searches for AI-focused companies based in New York.</li> <li> <p>Compiles a list with relevant company details.</p> </li> <li> <p>Job Searcher Agent:</p> </li> <li>Visits each company's career page.</li> <li> <p>Identifies job openings that match the user's skills and preferences.</p> </li> <li> <p>Autocode Agent:</p> </li> <li>Automates the application process by uploading the user's resume.</li> <li> <p>Fills out required application fields using extracted data.</p> </li> <li> <p>Emailer Agent:</p> </li> <li>Identifies and compiles contact information for key personnel within each company.</li> <li>Sends personalized emails to these contacts to initiate networking efforts.</li> </ul>"},{"location":"11_autonomous_ai_job_seeker_agent.html#step-4-continuous-engagement-and-optimization","title":"Step 4: Continuous Engagement and Optimization","text":"<ul> <li>Response Monitoring:</li> <li> <p>Agents track responses from job applications and outreach emails.</p> </li> <li> <p>Follow-Up Scheduling:</p> </li> <li> <p>Emailer Agent schedules follow-up emails for non-responsive contacts or to further engage interested parties.</p> </li> <li> <p>Strategy Refinement:</p> </li> <li>Based on response rates, the Orchestrator adjusts the outreach strategies.</li> <li>This may include modifying email templates, targeting different job roles, or expanding the search criteria.</li> </ul>"},{"location":"11_autonomous_ai_job_seeker_agent.html#benefits","title":"Benefits","text":"<ul> <li>Time-Saving: Automates the labor-intensive process of job searching and application, allowing users to focus on preparing for interviews.</li> <li>Increased Opportunities: Maximizes the number of applications submitted, enhancing the likelihood of securing job interviews.</li> <li>Personalized Networking: Crafts tailored messages to potential employers, increasing the chances of positive responses.</li> <li>Organization: Maintains a structured record of applications and communications, preventing missed opportunities.</li> <li>Consistency: Ensures regular follow-ups and persistent engagement without manual effort.</li> </ul>"},{"location":"11_autonomous_ai_job_seeker_agent.html#visual-aid","title":"Visual Aid","text":"<p>Depicts the interaction between the orchestrator and various agents during the job search and application process.</p>"},{"location":"11_autonomous_ai_sales_agent.html","title":"Autonomous AI Sales Agent","text":""},{"location":"11_autonomous_ai_sales_agent.html#overview","title":"Overview","text":"<p>The Autonomous AI Sales Agent is engineered to optimize the sales outreach process by automating lead generation, personalized email drafting, and follow-up communications. This agent works in tandem with other specialized agents to manage and execute sales campaigns efficiently.</p>"},{"location":"11_autonomous_ai_sales_agent.html#scenario","title":"Scenario","text":"<p>User Query:</p> <p>Thought for 7 seconds</p> <p>Absolutely! Creating separate, detailed markdown files for each use case will provide clarity and depth to your documentation, making it easier for users to understand how Panacea operates in various scenarios. Below, you'll find step-by-step instructions on how to structure these use cases, along with comprehensive content for each markdown file. Additionally, I'll guide you on updating the mkdocs.yml configuration to incorporate these new sections seamlessly.</p> <ol> <li>Directory Structure Enhancement To organize your use cases effectively, create a dedicated directory for them within the docs/ folder. This structure promotes better manageability and scalability as you add more use cases in the future.</li> </ol> <p>Updated Directory Structure css Copy code panacea-docs/ \u251c\u2500\u2500 docs/ \u2502   \u251c\u2500\u2500 images/ \u2502   \u2502   \u251c\u2500\u2500 logo.png \u2502   \u2502   \u251c\u2500\u2500 favicon.ico \u2502   \u2502   \u2514\u2500\u2500 system_architecture_diagram.png \u2502   \u251c\u2500\u2500 use_cases/ \u2502   \u2502   \u251c\u2500\u2500 autonomous_ai_coding_agent.md \u2502   \u2502   \u251c\u2500\u2500 autonomous_ai_sales_agent.md \u2502   \u2502   \u2514\u2500\u2500 job_seeker_agent.md \u2502   \u251c\u2500\u2500 1_getting_started.md \u2502   \u251c\u2500\u2500 2_introduction.md \u2502   \u251c\u2500\u2500 3_system_architecture_overview.md \u2502   \u251c\u2500\u2500 4_key_components.md \u2502   \u251c\u2500\u2500 5_agent_design.md \u2502   \u251c\u2500\u2500 6_workflow_management.md \u2502   \u251c\u2500\u2500 7_communication_framework.md \u2502   \u251c\u2500\u2500 8_user_interface.md \u2502   \u251c\u2500\u2500 9_api_and_enterprise_features.md \u2502   \u251c\u2500\u2500 10_deployment.md \u2502   \u251c\u2500\u2500 11_logging_and_monitoring.md \u2502   \u251c\u2500\u2500 12_glossary.md \u2502   \u251c\u2500\u2500 13_faq.md \u2502   \u251c\u2500\u2500 14_use_cases.md (to be deprecated or redirected) \u2502   \u2514\u2500\u2500 15_references.md \u251c\u2500\u2500 mkdocs.yml \u2514\u2500\u2500 requirements.txt 2. Creating Detailed Use Case Markdown Files For each use case, create a separate markdown file within the docs/use_cases/ directory. Below are the detailed contents for each of the three use cases you provided.</p> <p>2.1. Autonomous AI Coding Agent File Path: docs/use_cases/autonomous_ai_coding_agent.md markdown Copy code</p>"},{"location":"11_autonomous_ai_sales_agent.html#autonomous-ai-coding-agent","title":"Autonomous AI Coding Agent","text":""},{"location":"11_autonomous_ai_sales_agent.html#overview_1","title":"Overview","text":"<p>The Autonomous AI Coding Agent is designed to streamline the software development process by automating coding tasks, managing dependencies, and iteratively improving code quality. This agent collaborates with other specialized agents to handle complex workflows efficiently.</p>"},{"location":"11_autonomous_ai_sales_agent.html#scenario_1","title":"Scenario","text":"<p>User Query: Create a Python script that scrapes data from a website, stores it in a CSV file, and optimizes the code for better performance.</p> <p>markdown Copy code</p>"},{"location":"11_autonomous_ai_sales_agent.html#workflow-breakdown","title":"Workflow Breakdown","text":"<ol> <li>Query Interpretation by Orchestrator:</li> <li>The Orchestrator receives the natural language query and parses it to understand the user's intent.</li> <li> <p>It identifies the primary tasks:</p> <ul> <li>Web scraping</li> <li>Data storage in CSV</li> <li>Code optimization</li> </ul> </li> <li> <p>Task Definition and Assignment:</p> </li> <li>Task 1: Scrape data from the specified website.<ul> <li>Assigned to: Web Surfer Agent</li> </ul> </li> <li>Task 2: Store scraped data in a CSV file.<ul> <li>Assigned to: Data Management Agent</li> </ul> </li> <li> <p>Task 3: Optimize the Python script for performance.</p> <ul> <li>Assigned to: Code Optimizer Agent</li> </ul> </li> <li> <p>Agent Collaboration and Execution:</p> </li> </ol> <p>### Task 1: Web Scraping    - Web Surfer Agent searches for the target website and retrieves the necessary HTML content.    - It identifies the data points to be scraped based on the user's specifications.</p> <p>### Task 2: Data Storage    - Data Management Agent receives the scraped data and formats it appropriately.    - It creates a CSV file and populates it with the retrieved data.</p> <p>### Task 3: Code Optimization    - Code Optimizer Agent reviews the initial Python script generated by the Autocode Agent.    - It identifies inefficiencies and applies best practices to enhance performance.    - If errors are detected during optimization, it re-engages the Web Surfer Agent to gather solutions from relevant documentation or forums.</p> <ol> <li>Iterative Improvement:</li> <li>After initial execution, the Autocode Agent tests the script.</li> <li>If errors arise, the orchestrator redefines tasks to address and fix the issues, ensuring the script runs smoothly.</li> <li>The system then prompts for further enhancements, such as adding logging or handling exceptions, and iteratively calls itself to implement these features.</li> </ol>"},{"location":"11_autonomous_ai_sales_agent.html#detailed-interaction-flow","title":"Detailed Interaction Flow","text":""},{"location":"11_autonomous_ai_sales_agent.html#step-1-initial-query","title":"Step 1: Initial Query","text":"<ul> <li>User: \"Create a Python script that scrapes data from a website, stores it in a CSV file, and optimizes the code for better performance.\"</li> </ul>"},{"location":"11_autonomous_ai_sales_agent.html#step-2-orchestrator-processing","title":"Step 2: Orchestrator Processing","text":"<ul> <li>Orchestrator:</li> <li>Parses the query to extract tasks.</li> <li>Defines the workflow and assigns tasks to respective agents.</li> </ul>"},{"location":"11_autonomous_ai_sales_agent.html#step-3-task-execution-by-agents","title":"Step 3: Task Execution by Agents","text":"<ul> <li>Web Surfer Agent:</li> <li>Identifies the target website.</li> <li>Retrieves HTML content.</li> <li> <p>Extracts necessary data points.</p> </li> <li> <p>Data Management Agent:</p> </li> <li>Formats the extracted data.</li> <li> <p>Writes data to a CSV file.</p> </li> <li> <p>Autocode Agent:</p> </li> <li>Generates the initial Python script incorporating the scraping and data storage logic.</li> </ul>"},{"location":"11_autonomous_ai_sales_agent.html#step-4-code-optimization","title":"Step 4: Code Optimization","text":"<ul> <li>Code Optimizer Agent:</li> <li>Analyzes the initial script.</li> <li>Refactors code for efficiency (e.g., using list comprehensions, optimizing loops).</li> <li>Implements error handling and logging.</li> </ul>"},{"location":"11_autonomous_ai_sales_agent.html#step-5-testing-and-iteration","title":"Step 5: Testing and Iteration","text":"<ul> <li>Autocode Agent:</li> <li>Executes the optimized script.</li> <li> <p>Detects any runtime errors.</p> </li> <li> <p>Orchestrator:</p> </li> <li>If errors are found, redefines tasks to address them.</li> <li> <p>Assigns agents to fix identified issues.</p> </li> <li> <p>Cycle Continues:</p> </li> <li>The system iteratively improves the script until it meets the desired performance and functionality standards.</li> </ul>"},{"location":"11_autonomous_ai_sales_agent.html#benefits","title":"Benefits","text":"<ul> <li>Efficiency: Automates repetitive coding tasks, reducing development time.</li> <li>Accuracy: Minimizes human errors in coding and data handling.</li> <li>Scalability: Easily adapts to more complex projects by adding or modifying agents.</li> <li>Continuous Improvement: Iteratively enhances code quality through autonomous optimizations.</li> <li>User-Friendly: Allows users with minimal coding knowledge to generate and optimize scripts effectively.</li> </ul>"},{"location":"11_autonomous_ai_sales_agent.html#visual-aid","title":"Visual Aid","text":"<p> Illustrates the collaboration between the orchestrator and various agents during the sales outreach process.</p> <p>2.2. Autonomous AI Sales Agent File Path: docs/use_cases/autonomous_ai_sales_agent.md markdown Copy code</p>"},{"location":"11_autonomous_ai_sales_agent.html#autonomous-ai-sales-agent_1","title":"Autonomous AI Sales Agent","text":""},{"location":"11_autonomous_ai_sales_agent.html#overview_2","title":"Overview","text":"<p>The Autonomous AI Sales Agent is engineered to optimize the sales outreach process by automating lead generation, personalized email drafting, and follow-up communications. This agent works in tandem with other specialized agents to manage and execute sales campaigns efficiently.</p>"},{"location":"11_autonomous_ai_sales_agent.html#scenario_2","title":"Scenario","text":"<p>User Query: Search for potential clients in the technology sector, compile a list of prospects, and initiate personalized email outreach to promote our AI solutions.</p>"},{"location":"11_autonomous_ai_sales_agent.html#workflow-breakdown_1","title":"Workflow Breakdown","text":"<ol> <li>Query Interpretation by Orchestrator:</li> <li> <p>The Orchestrator analyzes the natural language query to determine the key objectives:</p> <ul> <li>Lead generation in the technology sector.</li> <li>Compiling a prospect list.</li> <li>Initiating personalized email outreach.</li> </ul> </li> <li> <p>Task Definition and Assignment:</p> </li> <li>Task 1: Search for potential clients in the technology sector.<ul> <li>Assigned to: Web Surfer Agent</li> </ul> </li> <li>Task 2: Compile and filter a list of high-potential prospects.<ul> <li>Assigned to: Lead Management Agent</li> </ul> </li> <li>Task 3: Draft and send personalized emails to prospects.<ul> <li>Assigned to: Emailer Agent</li> </ul> </li> <li> <p>Task 4: Schedule and manage follow-up communications.</p> <ul> <li>Assigned to: Follow-Up Agent</li> </ul> </li> <li> <p>Agent Collaboration and Execution:</p> </li> </ol> <p>### Task 1: Lead Generation    - Web Surfer Agent conducts targeted searches using keywords related to the technology sector.    - It identifies companies and key decision-makers who would benefit from AI solutions.</p> <p>### Task 2: Lead Compilation    - Lead Management Agent filters the gathered data based on criteria such as company size, revenue, and industry relevance.    - It compiles a refined list of prospects ready for outreach.</p> <p>### Task 3: Email Drafting and Sending    - Emailer Agent drafts personalized emails tailored to each prospect's specific needs and company profile.    - It leverages data such as the prospect's role, company achievements, and pain points to craft compelling messages.    - Emails are scheduled and sent at optimal times to maximize engagement.</p> <p>### Task 4: Follow-Up Communications    - Follow-Up Agent monitors email responses and schedules follow-up emails for prospects who have not responded.    - It maintains communication logs to track interactions and outcomes.</p> <ol> <li>Iterative Outreach and Optimization:</li> <li>The Autonomous Iteration process ensures that the sales outreach remains consistent and evolves based on prospect interactions.</li> <li>Agents analyze response rates and adjust strategies to improve effectiveness, such as tweaking email templates or adjusting target criteria.</li> </ol>"},{"location":"11_autonomous_ai_sales_agent.html#detailed-interaction-flow_1","title":"Detailed Interaction Flow","text":""},{"location":"11_autonomous_ai_sales_agent.html#step-1-initial-query_1","title":"Step 1: Initial Query","text":"<ul> <li>User: \"Search for potential clients in the technology sector, compile a list of prospects, and initiate personalized email outreach to promote our AI solutions.\"</li> </ul>"},{"location":"11_autonomous_ai_sales_agent.html#step-2-orchestrator-processing_1","title":"Step 2: Orchestrator Processing","text":"<ul> <li>Orchestrator:</li> <li>Parses the query to identify tasks.</li> <li>Defines the workflow and assigns tasks to respective agents.</li> </ul>"},{"location":"11_autonomous_ai_sales_agent.html#step-3-task-execution-by-agents_1","title":"Step 3: Task Execution by Agents","text":"<ul> <li>Web Surfer Agent:</li> <li>Utilizes industry-specific keywords to find potential clients.</li> <li> <p>Extracts relevant company information and contact details.</p> </li> <li> <p>Lead Management Agent:</p> </li> <li>Filters leads based on predefined criteria (e.g., company size, location).</li> <li> <p>Prioritizes prospects with higher conversion potential.</p> </li> <li> <p>Emailer Agent:</p> </li> <li>Crafts personalized email templates for each prospect.</li> <li>Incorporates data-driven insights to tailor messages effectively.</li> <li> <p>Sends out emails and schedules follow-ups as needed.</p> </li> <li> <p>Follow-Up Agent:</p> </li> <li>Tracks email open rates and responses.</li> <li>Automates follow-up emails for non-respondents.</li> <li>Updates lead status based on interactions.</li> </ul>"},{"location":"11_autonomous_ai_sales_agent.html#step-4-continuous-optimization","title":"Step 4: Continuous Optimization","text":"<ul> <li>Performance Monitoring:</li> <li>Agents analyze metrics such as open rates, response rates, and conversion rates.</li> <li> <p>Orchestrator adjusts strategies based on performance data to enhance outreach effectiveness.</p> </li> <li> <p>Strategy Refinement:</p> </li> <li>Modifies email content, sending times, and targeting criteria to improve engagement.</li> <li>Iteratively enhances the sales campaign for better results.</li> </ul>"},{"location":"11_autonomous_ai_sales_agent.html#benefits_1","title":"Benefits","text":"<ul> <li>Efficiency: Automates the entire sales outreach process, saving time and resources.</li> <li>Personalization: Crafts tailored messages that resonate with each prospect, increasing engagement rates.</li> <li>Scalability: Manages large volumes of leads effortlessly, allowing sales teams to focus on closing deals.</li> <li>Consistency: Maintains regular communication with prospects without manual intervention.</li> <li>Data-Driven Insights: Utilizes performance metrics to continuously refine and improve sales strategies.</li> </ul>"},{"location":"11_autonomous_query_agent.html","title":"Autonomous Query Agent","text":""},{"location":"11_autonomous_query_agent.html#overview","title":"Overview","text":"<p>The Autonomous Query Agent exemplifies Panacea's advanced capabilities by autonomously determining optimal queries based on the surrounding environment and predefined reward mechanisms. This agent operates independently, identifying tasks that maximize rewards and executing them without explicit user instructions. This level of autonomy enhances efficiency, adaptability, and intelligent decision-making within the Panacea ecosystem.</p>"},{"location":"11_autonomous_query_agent.html#scenario","title":"Scenario","text":"<p>Objective: Enable Panacea to proactively identify and execute tasks that align with user-defined goals and environmental factors, optimizing outcomes through autonomous query generation and execution.</p> <p>User Intent: While the user may not provide direct instructions, they set up the environment and define rewards that guide the AI's autonomous behavior.</p>"},{"location":"11_autonomous_query_agent.html#workflow-breakdown","title":"Workflow Breakdown","text":"<ol> <li>Environment Setup and Reward Definition:</li> <li> <p>User Configuration:</p> <ul> <li>Defines the operational environment parameters (e.g., available resources, data sources).</li> <li>Establishes reward mechanisms that prioritize certain outcomes over others (e.g., efficiency, accuracy, cost-effectiveness).</li> </ul> </li> <li> <p>Orchestrator's Role in Autonomous Operation:</p> </li> <li>Task Identification:<ul> <li>Continuously monitors the environment and evaluates potential opportunities or challenges.</li> <li>Uses the defined rewards to assess which tasks to prioritize and execute.</li> </ul> </li> <li> <p>Query Generation:</p> <ul> <li>Formulates natural language queries that align with the highest-reward tasks.</li> <li>Ensures queries are contextually relevant and optimized for desired outcomes.</li> </ul> </li> <li> <p>Agent Collaboration and Execution:</p> </li> </ol> <p>### Step 1: Environment Monitoring    - Monitoring Agent:      - Continuously scans the environment for changes, new data, or emerging trends.      - Identifies gaps, opportunities, or areas needing attention based on user-defined parameters.</p> <p>### Step 2: Task Evaluation and Reward Assessment    - Evaluation Agent:      - Analyzes identified opportunities against the reward criteria.      - Determines the potential rewards and impacts of executing specific tasks.      - Prioritizes tasks that offer the highest rewards.</p> <p>### Step 3: Query Formulation    - Query Generator Agent:      - Constructs precise and effective natural language queries tailored to the prioritized tasks.      - Ensures queries are actionable and provide clear directives to other agents.</p> <p>### Step 4: Task Execution    - Task-Specific Agents:      - Web Surfer Agent: Executes web searches to gather necessary information or resources.      - Autocode Agent: Develops or modifies code to address identified needs.      - Data Analyst Agent: Processes and analyzes data to inform decision-making.      - Emailer Agent: Communicates with stakeholders or external parties as required.</p> <p>### Step 5: Outcome Evaluation and Iteration    - Feedback Agent:      - Assesses the outcomes of executed tasks against the defined rewards.      - Provides feedback to the orchestrator for continuous improvement.    - Orchestrator:      - Adjusts future task prioritization and query formulations based on feedback.      - Enhances the agent's decision-making algorithms to better align with user goals.</p>"},{"location":"11_autonomous_query_agent.html#detailed-interaction-flow","title":"Detailed Interaction Flow","text":""},{"location":"11_autonomous_query_agent.html#step-1-initial-environment-setup","title":"Step 1: Initial Environment Setup","text":"<ul> <li>User: Configures Panacea by defining the operational environment and setting up reward criteria.</li> <li>Example Configuration: <pre><code>environment:\ndata_sources:\n- internal_database\n- public_api\navailable_resources:\n- CPU: 8 cores\n- Memory: 16GB\n- Storage: 100GB SSD\nrewards:\nefficiency: 0.4\naccuracy: 0.3\ncost_effectiveness: 0.3\n</code></pre></li> </ul>"},{"location":"11_autonomous_query_agent.html#step-2-autonomous-monitoring-and-evaluation","title":"Step 2: Autonomous Monitoring and Evaluation","text":"<ul> <li>Monitoring Agent: Continuously scans the environment for new data or changes.</li> <li> <p>Detected Change: New data available from a public API related to market trends.</p> </li> <li> <p>Evaluation Agent: Assesses the potential tasks that can be performed with the new data.</p> </li> <li>Task 1: Analyze market trends to identify investment opportunities.<ul> <li>Reward Calculation:</li> <li>Efficiency: High</li> <li>Accuracy: Medium</li> <li>Cost-Effectiveness: High</li> </ul> </li> </ul>"},{"location":"11_autonomous_query_agent.html#step-3-query-generation-and-task-assignment","title":"Step 3: Query Generation and Task Assignment","text":"<ul> <li>Query Generator Agent: Formulates a natural language query based on Task 1.</li> <li> <p>Generated Query: <pre><code>Analyze the latest market trends from the public API to identify top investment opportunities for Q3 2024.\n</code></pre></p> </li> <li> <p>Orchestrator: Assigns the query to the relevant agents for execution.</p> </li> </ul>"},{"location":"11_autonomous_query_agent.html#step-4-task-execution-by-agents","title":"Step 4: Task Execution by Agents","text":"<ul> <li> <p>Web Surfer Agent: Fetches the latest market data from the public API.</p> </li> <li> <p>Data Analyst Agent: Processes and analyzes the fetched data to identify investment opportunities.</p> </li> <li> <p>Autocode Agent: Develops a report summarizing the findings.</p> </li> <li> <p>Emailer Agent: Sends the report to the user for review.</p> </li> </ul>"},{"location":"11_autonomous_query_agent.html#step-5-outcome-evaluation-and-iteration","title":"Step 5: Outcome Evaluation and Iteration","text":"<ul> <li>Feedback Agent: Evaluates the report's usefulness and accuracy based on user feedback.</li> <li> <p>User Feedback: \"The report is accurate but could benefit from more detailed analysis on emerging markets.\"</p> </li> <li> <p>Orchestrator: Adjusts future task prioritization to place greater emphasis on detailed analysis.</p> </li> <li> <p>Query Generator Agent: Formulates a new query to address the feedback.</p> </li> <li> <p>New Query: <pre><code>Provide a detailed analysis of emerging markets within the latest market trends data to identify potential high-growth investment opportunities.\n</code></pre></p> </li> <li> <p>Cycle Continues: The autonomous system iterates to refine tasks and improve outcomes based on ongoing feedback.</p> </li> </ul>"},{"location":"11_autonomous_query_agent.html#benefits","title":"Benefits","text":"<ul> <li>Proactive Operation: Enables Panacea to anticipate and address needs without explicit user instructions.</li> <li>Continuous Improvement: Iteratively enhances task execution based on feedback and performance metrics.</li> <li>Optimized Decision-Making: Aligns task prioritization with user-defined rewards to maximize desired outcomes.</li> <li>Resource Efficiency: Utilizes available resources effectively by autonomously managing task allocation and execution.</li> <li>Scalability: Adapts to varying environments and complex scenarios, making it suitable for diverse applications.</li> </ul>"},{"location":"11_autonomous_query_agent.html#visual-aid","title":"Visual Aid","text":"<p>Illustrates the autonomous interaction between the orchestrator and various agents in generating and executing queries based on environmental context and rewards.</p>"},{"location":"1_introduction.html","title":"Introduction","text":"<p>Autonomous Intelligence is an open-sourced, research-driven initiative aimed at building collaborative multi-agent AI systems. By combining modular design principles and cutting-edge machine learning techniques, this project empowers developers and organizations to build, deploy, and optimize AI agents that work well in dynamic, complex environments.</p>"},{"location":"1_introduction.html#general-purpose-multi-agent-ai-framework","title":"General Purpose Multi-Agent AI Framework","text":"<p>The framework provides a robust infrastructure for creating and managing multiple AI agents. It enables seamless collaboration between agents to tackle complex tasks, dynamically adapting to user inputs and changing conditions.</p> <p></p>"},{"location":"1_introduction.html#domain-specific-agent-registry","title":"Domain Specific Agent Registry","text":"<p>The registry offers a catalog of prebuilt agents optimized for specific domains, such as coding, data analysis, and natural language processing. This allows users to quickly integrate tailored solutions into their workflows without extensive setup.</p> <p></p>"},{"location":"2_key_components.html","title":"Core Components","text":"<p>Our agentic AI framework comprises of several core components:</p> Component Description Orchestrator Central hub for task assignment, execution, and monitoring. Manages agent interactions and refines workflows dynamically. Agent An autonomous unit programmed to perform tasks, make decisions, and communicate with other agents. Task A specific assignment completed by an agent, providing all necessary details like description, tools, and responsibilities. Crew A collaborative group of agents working together to achieve a set of tasks. Crews define strategies for task execution and agent collaboration. Process Implementations Frameworks for agent collaboration. This includes sequential tasks that are executed in an orderly progression, or hierarchical tasks are managed via a structured chain of command Large Language Models (LLMs) Backbone of intelligent agents, enabling capabilities like natural language understanding and reasoning. Includes models like GPT, Claude, Mistral, Gemini, and Llama that are Optimized for complex workflows. Tool A skill or function agents use to perform actions, that includes capabilities like search, computer use, data extraction, file uploading and advanced interactions. Agent Registry A structured catalog organizing agents by domain, task type, and functionality, allowing users to deploy agents seamlessly. Frontend Interface Drag-and-drop visual workflow builder and real-time dashboards for monitoring, debugging, and optimizing agent performance."},{"location":"2_system_architecture_overview.html","title":"System Architecture Overview","text":"<p>Our architecture is built around a decentralized network of specialized agents that work both independently and collaboratively. These agents communicate through defined pathways, managed by an orchestrator that ensures tasks are distributed and executed efficiently.</p> <p></p>"},{"location":"2_system_architecture_overview.html#key-features","title":"Key Features","text":"Feature Description Decentralized Agents Each agent operates autonomously while collaborating to achieve complex tasks. Orchestrator Acts as the central command center, managing task distribution and workflow coordination. Communication Edges Enable seamless data exchange and coordination between agents. Logging &amp; Monitoring Ensure transparency, performance tracking, and issue resolution. Dynamic Workflows Build complex workflows with drag-and-drop tools. Agent Collaboration Enable sequential, parallel, or hierarchical execution of tasks. Customizable Framework Integrate third-party apps and tools, such as Slack, AWS, or Google Workspace. Real-Time Debugging Visualize and troubleshoot workflows using interactive flowcharts. Model-Agnostic Design Supports various models, including OpenAI, Claude, Llama, and Mistral. Private Deployments Operate securely in local environments with privacy-preserving configurations."},{"location":"3_agent_environment.html","title":"Agent Environment","text":"<p>Each agent operates within its own environment, a dedicated workspace configured with the necessary tools and resources. This isolation ensures security and optimal performance, allowing agents to function without interference while maintaining the ability to collaborate when needed.</p>"},{"location":"3_agent_environment.html#key-aspects","title":"Key Aspects","text":"<ul> <li>Resource Allocation: Each environment is provisioned with the necessary computational resources, such as CPU, memory, and storage, tailored to the agent's specific tasks.</li> <li>Security: Environments are sandboxed to prevent unauthorized access and ensure data integrity.</li> <li>Customization: Environments can be customized based on the agent's requirements, allowing for flexibility and scalability.</li> </ul>"},{"location":"3_agent_environment.html#benefits","title":"Benefits","text":"<ul> <li>Isolation: Prevents cross-agent interference, ensuring that each agent operates within its designated parameters.</li> <li>Performance Optimization: Allocates resources efficiently to maximize agent performance based on task demands.</li> <li>Scalability: Easily scale agent environments to accommodate growing workloads or introduce new functionalities.</li> </ul>"},{"location":"3_agent_templates.html","title":"Agent Templates","text":"<p>We provide a few example agent templates, which can be called. Examples include:</p> <ul> <li>Web Surfer Agent: Navigates the web to gather information based on user queries.</li> <li>Coder Agent: Writes code and reasons to solve tasks.</li> <li>Computer Terminal Agent: Executes code written by the coder agent.</li> <li>File Reader Agent: Processes and extracts data from various file formats.</li> <li>Email Automation Agent: Automates the sending, organizing, and managing of emails.</li> <li>Data Analyst Agent: Analyzes data sets to generate insights and provide analytics.</li> </ul> <p></p>"},{"location":"3_agent_templates.html#custom-agents","title":"Custom Agents","text":"<p>In addition to predefined agents, we allow users to create custom agents tailored to specific needs. This flexibility ensures that Panacea can adapt to a wide range of tasks and industries.</p>"},{"location":"3_agent_templates.html#creating-a-custom-agent","title":"Creating a Custom Agent","text":"<ol> <li>Define the Agent's Purpose: Determine the specific task or function the agent will perform.</li> <li>Configure Capabilities: Set up the tools and resources the agent will require.</li> <li>Set Communication Protocols: Define how the agent will interact with other agents and the orchestrator.</li> <li>Deploy the Agent: Launch the agent within the Panacea environment, ready to execute tasks.</li> </ol>"},{"location":"4_orchestration.html","title":"Orchestration","text":"<p>The orchestrator plays a pivotal role in managing workflows. It interprets user queries, breaks them down into actionable tasks, and assigns these tasks to the appropriate agents. The orchestrator ensures that tasks are distributed efficiently, optimizing workflow execution and ensuring timely completion.</p> <p></p> <p>The orchestrator ensures that tasks are distributed efficiently, optimizing workflow execution and ensuring timely completion.</p>"},{"location":"4_orchestration.html#orchestration-process","title":"Orchestration Process","text":"<p>Task execution is automated through dynamic selection of the best agents, tools, and workflows for the job. The system handles dependencies, monitors progress, and troubleshoots issues in real time. The following process is how this works:</p> <ol> <li>Query Interpretation: The orchestrator parses the natural language query to understand the user's intent and extract relevant entities.</li> <li>Task Breakdown: The query is decomposed into smaller, manageable tasks that can be assigned to individual agents.</li> <li>Task Assignment: Tasks are allocated to the appropriate agents based on their specialization and current workload.</li> <li>Monitoring and Adjustment: The orchestrator monitors task execution, making adjustments as necessary to handle delays or errors.</li> </ol>"},{"location":"4_orchestration.html#orchestrator-features","title":"Orchestrator Features","text":"<ul> <li>Intelligent Routing: Utilizes AI to determine the most efficient agent for each task.</li> <li>Dynamic Scaling: Adjusts the number of active agents based on task volume and complexity.</li> <li>Failure Recovery: Implements strategies to recover from agent failures, ensuring workflow continuity.</li> <li>Performance Optimization: Continuously analyzes workflow performance to identify and eliminate bottlenecks.</li> </ul>"},{"location":"4_task_execution.html","title":"Task Execution","text":"<p>Tasks are the fundamental units of work within Panacea. Each task is a specific instruction that an agent needs to execute. Tasks can be handled in series or in parallel, depending on their nature and dependencies.</p> <p></p>"},{"location":"4_task_execution.html#execution-modes","title":"Execution Modes","text":"<ul> <li>Sequential Execution: Tasks are executed one after another, suitable for dependent tasks where the output of one task is required for the next.</li> <li>Parallel Execution: Multiple tasks are executed simultaneously, ideal for independent tasks that can be processed concurrently to save time.</li> </ul>"},{"location":"4_task_execution.html#task-lifecycle","title":"Task Lifecycle","text":"<ol> <li>Creation: Tasks are created based on user queries or predefined workflows.</li> <li>Assignment: The orchestrator assigns tasks to the appropriate agents.</li> <li>Execution: Agents execute the tasks within their environments.</li> <li>Completion: Upon successful execution, results are returned and logged.</li> <li>Monitoring: Ongoing tracking ensures tasks are completed as expected.</li> </ol>"},{"location":"4_task_execution.html#task-management-features","title":"Task Management Features","text":"<ul> <li>Priority Levels: Assign priorities to tasks to manage execution order effectively.</li> <li>Dependency Handling: Manage task dependencies to ensure proper execution flow.</li> <li>Error Handling: Implement mechanisms to handle task failures gracefully, including retries and fallbacks.</li> </ul>"},{"location":"5_communication_framework.html","title":"Communication Framework","text":"<p>Communication between agents is facilitated through edges, which are the defined pathways that enable data exchange and coordination. This framework ensures that agents can work together seamlessly, sharing information and collaborating to complete complex workflows without redundancy or conflict.</p>"},{"location":"5_communication_framework.html#communication-features","title":"Communication Features","text":"<ul> <li>Message Passing: Agents communicate by sending and receiving messages through the edges, ensuring clear and direct information flow.</li> <li>Data Sharing: Agents can share data outputs and inputs, enabling collaborative task execution and data-driven decision-making.</li> <li>Synchronization: The framework supports synchronization mechanisms to manage dependencies and ensure orderly task execution.</li> </ul>"},{"location":"5_communication_framework.html#advantages","title":"Advantages","text":"<ul> <li>Scalability: Easily add or remove agents without disrupting the overall system.</li> <li>Flexibility: Supports various communication protocols to cater to different agent requirements.</li> <li>Resilience: Enhances system robustness by enabling failover and redundancy in communication pathways.</li> </ul>"},{"location":"5_communication_framework.html#communication-protocols","title":"Communication Protocols","text":"<ul> <li>RESTful APIs: For standard request-response interactions, ensuring compatibility and ease of integration.</li> <li>WebSockets: Facilitates real-time, bi-directional communication for tasks requiring immediate updates.</li> <li>Message Queues: Implements reliable message passing with systems like RabbitMQ or Kafka to handle high-throughput data exchange.</li> </ul>"},{"location":"5_communication_framework.html#implementation-highlights","title":"Implementation Highlights","text":"<ul> <li>Asynchronous Communication: Ensures non-blocking interactions between agents, enhancing overall system efficiency.</li> <li>Security Measures: Encrypts all data transmissions to protect sensitive information during inter-agent communication.</li> <li>Monitoring Tools: Utilizes logging and monitoring systems to track communication flows and identify potential issues.</li> </ul>"},{"location":"6_agent_creation.html","title":"Agent Creation","text":"<p>Users can create and customize their own agents through the UI, tailoring them to specific tasks and workflows. This flexibility allows for the creation of a personalized swarm of agents that work together to handle complex processes.</p>"},{"location":"6_agent_creation.html#agent-creation-steps","title":"Agent Creation Steps","text":"<ol> <li>Select Agent Type: Choose from predefined agent types or define a custom agent based on specific needs.</li> <li>Configure Agent Settings: Set up agent-specific configurations, such as task parameters and resource allocations.</li> <li>Define Workflow: Specify how the agent interacts with other agents and the orchestrator within workflows.</li> <li>Deploy Agent: Launch the agent within the desired environment, making it ready to execute tasks.</li> </ol>"},{"location":"6_agent_creation.html#customization-options","title":"Customization Options","text":"<ul> <li>Task Specialization: Assign specific tasks or functions to each agent, ensuring they operate within their expertise.</li> <li>Resource Allocation: Allocate appropriate computational resources (CPU, memory, storage) to each agent to optimize performance.</li> <li>Integration Settings: Configure how agents integrate with external systems or APIs, enabling seamless data flow and functionality expansion.</li> <li>Security Settings: Define access controls and permissions to safeguard data and operations within each agent's environment.</li> </ul>"},{"location":"6_agent_creation.html#benefits","title":"Benefits","text":"<ul> <li>Personalization: Tailor agents to fit unique workflow requirements, enhancing productivity and efficiency.</li> <li>Scalability: Easily add or modify agents as organizational needs evolve, ensuring the system remains adaptable.</li> <li>Enhanced Collaboration: Configure agents to work in tandem, fostering a collaborative environment that can handle multifaceted tasks.</li> </ul>"},{"location":"6_chat_based_interface.html","title":"Chat-Based Interface","text":"<p>Panacea features an intuitive chat-based interface where users can interact with their agents effortlessly. By inputting natural language queries, users can instruct the orchestrator to perform various tasks, which are then delegated to the appropriate agents.</p>"},{"location":"6_chat_based_interface.html#example-interaction","title":"Example Interaction","text":"<p>User:</p>"},{"location":"6_chat_based_interface.html#features","title":"Features","text":"<ul> <li>Natural Language Processing: Understands and processes user queries in natural language, making interactions seamless and user-friendly.</li> <li>Real-Time Feedback: Provides immediate responses and updates on task progress, keeping users informed.</li> <li>User-Friendly Design: Simplifies interaction with complex workflows through an easy-to-use interface, reducing the learning curve.</li> <li>Progress Indicators: Visual elements like loading spinners and progress bars indicate ongoing tasks and their statuses.</li> <li>Agent Activity Notifications: Notifies users about specific actions taken by agents, enhancing transparency.</li> </ul>"},{"location":"6_chat_based_interface.html#benefits","title":"Benefits","text":"<ul> <li>Ease of Use: Allows users to perform complex tasks without needing technical expertise.</li> <li>Efficiency: Streamlines workflow management through straightforward, conversational interactions.</li> <li>Transparency: Keeps users informed about the status and progress of their tasks in real-time.</li> </ul>"},{"location":"7_developer_api.html","title":"API and Enterprise Features","text":""},{"location":"7_developer_api.html#developer-api","title":"Developer API","text":"<p>Panacea offers a robust API for developers, enabling integration with existing systems and the creation of custom agents. The API allows for programmatic control over agent creation, task assignment, and workflow management, fostering seamless automation within diverse applications.</p>"},{"location":"7_developer_api.html#key-features","title":"Key Features","text":"<ul> <li>Agent Management: Create, update, and delete agents programmatically.</li> <li>Task Assignment: Assign tasks to specific agents or groups of agents.</li> <li>Workflow Automation: Define and manage complex workflows through API endpoints.</li> <li>Real-Time Monitoring: Access real-time data on agent performance and task status.</li> <li>Secure Access: Utilize authentication mechanisms to protect API endpoints and ensure secure interactions.</li> </ul>"},{"location":"7_developer_api.html#api-endpoints-example","title":"API Endpoints Example","text":"<ul> <li>Create Agent: <code>POST /api/agents</code></li> <li>Assign Task: <code>POST /api/tasks</code></li> <li>Get Task Status: <code>GET /api/tasks/{task_id}</code></li> <li>List Agents: <code>GET /api/agents</code></li> <li>Delete Agent: <code>DELETE /api/agents/{agent_id}</code></li> </ul>"},{"location":"7_developer_api.html#sample-api-request","title":"Sample API Request","text":""},{"location":"7_developer_api.html#create-agent","title":"Create Agent","text":"<pre><code>POST /api/agents\n{\n\"type\": \"WebSurferAgent\",\n\"config\": {\n\"search_criteria\": {\n\"role\": \"Data Scientist\",\n\"location\": \"San Francisco\"\n}\n}\n}\n</code></pre>"},{"location":"7_enterprise_solutions.html","title":"7 enterprise solutions","text":""},{"location":"7_enterprise_solutions.html#enterprise-solutions","title":"Enterprise Solutions","text":"<p>For businesses requiring enhanced security and control, Panacea provides enterprise-grade solutions. These include dedicated support, advanced customization options, and the ability to run agents on-premise or within secure environments.</p>"},{"location":"7_enterprise_solutions.html#benefits","title":"Benefits","text":"<ul> <li>Data Privacy: Ensure all operations are conducted within your secure infrastructure, maintaining full control over sensitive data.</li> <li>Custom Integration: Seamlessly integrate Panacea with internal systems, databases, and third-party applications.</li> <li>Scalability: Handle large-scale workflows with a customizable network of agents, adaptable to growing business needs.</li> <li>Dedicated Support: Access to enterprise-level support and services, including priority response times and personalized assistance.</li> <li>Compliance Assurance: Meet industry-specific compliance and regulatory requirements with tailored solutions.</li> </ul>"},{"location":"7_enterprise_solutions.html#enterprise-features","title":"Enterprise Features","text":"<ul> <li>Private Deployment: Run Panacea within your own servers or secure cloud environments, ensuring data remains within your control.</li> <li>Advanced Security Measures: Implement enhanced security protocols, including encryption, multi-factor authentication, and role-based access controls.</li> <li>Custom Agent Development: Develop and deploy custom agents tailored to specific business needs, leveraging Panacea's flexible framework.</li> <li>Compliance Tools: Utilize built-in compliance tools to adhere to regulations such as GDPR, HIPAA, and industry-specific standards.</li> <li>Integration Services: Benefit from specialized integration services to connect Panacea with existing enterprise infrastructure and workflows.</li> <li>Performance Optimization: Optimize agent performance and resource allocation to meet the demands of large-scale operations.</li> </ul>"},{"location":"7_enterprise_solutions.html#use-cases","title":"Use Cases","text":"<ul> <li>Financial Services: Automate complex financial analyses, reporting, and compliance tasks with specialized agents.</li> <li>Healthcare: Manage patient data, appointment scheduling, and medical record processing securely and efficiently.</li> <li>Manufacturing: Streamline supply chain management, inventory tracking, and production monitoring through automated agents.</li> <li>Retail: Enhance customer service, inventory management, and sales analytics with tailored agent solutions.</li> <li>Technology: Support software development, system monitoring, and technical support with dedicated agents.</li> </ul>"},{"location":"8_local_deployment.html","title":"Local Deployment","text":"<p>Panacea can be deployed locally, allowing users to run agents on their own machines. This setup is ideal for individuals and small teams seeking to maintain full control over their data and workflows.</p>"},{"location":"8_local_deployment.html#deployment-steps","title":"Deployment Steps","text":"<ol> <li>Download the Desktop Application</li> <li>Available for major operating systems: Windows, macOS, and Linux.</li> <li> <p>Visit the Panacea Downloads Page to obtain the installer for your OS.</p> </li> <li> <p>Install and Configure</p> </li> <li>Run the installer and follow the on-screen instructions to set up Panacea on your machine.</li> <li> <p>Launch the Panacea application post-installation.</p> </li> <li> <p>Create Agents</p> </li> <li>Use the intuitive UI to create and customize your agents.</li> <li> <p>Select predefined agent types or define custom agents based on your specific needs.</p> </li> <li> <p>Start Automating</p> </li> <li>Begin issuing natural language commands through the chat interface.</li> <li>Monitor task progress and agent activities in real-time.</li> </ol> <p></p>"},{"location":"8_local_deployment.html#benefits","title":"Benefits","text":"<ul> <li>Full Control: Maintain complete ownership of your data and workflows, ensuring privacy and security.</li> <li>Offline Access: Operate without relying on internet connectivity, ideal for secure environments or areas with limited connectivity.</li> <li>Customization: Tailor the deployment to fit specific local requirements, optimizing performance and resource usage.</li> </ul>"},{"location":"8_local_deployment.html#system-requirements","title":"System Requirements","text":"<ul> <li>Operating System: Windows 10 or later, macOS 10.14 or later, Linux (Ubuntu 18.04 or later)</li> <li>Processor: Intel i5 or equivalent</li> <li>Memory: Minimum 8GB RAM (16GB recommended)</li> <li>Storage: At least 10GB of free disk space</li> <li>Network: Internet connection required for initial setup and updates</li> </ul>"},{"location":"8_local_deployment.html#support","title":"Support","text":"<p>For assistance with local deployment, visit our Support Center or contact our support team:</p> <ul> <li>Email: support@panacea.ai</li> <li>Phone: +1 (800) 123-4567</li> </ul>"},{"location":"8_private_deployment.html","title":"Private Deployment","text":"<p>For organizations requiring enhanced security and control, Panacea supports private deployments. Agents can run within your own servers or secure cloud environments, ensuring compliance with data protection regulations.</p>"},{"location":"8_private_deployment.html#advantages","title":"Advantages","text":"<ul> <li>Enhanced Security: Protect sensitive data within your controlled environment, minimizing exposure risks.</li> <li>Custom Integration: Seamlessly integrate Panacea with internal systems, databases, and third-party applications.</li> <li>Dedicated Resources: Allocate resources based on organizational needs, ensuring optimal performance and scalability.</li> <li>Compliance Assurance: Meet industry-specific compliance and regulatory requirements with tailored solutions.</li> </ul>"},{"location":"8_private_deployment.html#deployment-options","title":"Deployment Options","text":"<ul> <li>On-Premise Servers: Install Panacea on your own hardware infrastructure for maximum control and security.</li> <li>Secure Cloud Environments: Deploy within trusted cloud services (e.g., AWS, Azure, Google Cloud) with robust security measures.</li> <li>Hybrid Deployment: Combine on-premise and cloud deployments to leverage the benefits of both environments, ensuring flexibility and scalability.</li> </ul>"},{"location":"8_private_deployment.html#deployment-steps","title":"Deployment Steps","text":"<ol> <li>Prepare Infrastructure</li> <li>Set up servers or secure cloud environments according to your organizational requirements.</li> <li> <p>Ensure necessary network configurations, firewalls, and security protocols are in place.</p> </li> <li> <p>Install Panacea</p> </li> <li>Follow the enterprise installation guide available in the Panacea Documentation to deploy Panacea within your infrastructure.</li> <li> <p>Configure environment variables, API keys, and other necessary settings during installation.</p> </li> <li> <p>Configure Security</p> </li> <li>Implement necessary security protocols, including encryption (TLS/SSL), access controls, and authentication mechanisms.</li> <li> <p>Set up role-based access controls (RBAC) to manage user and agent permissions effectively.</p> </li> <li> <p>Integrate Systems</p> </li> <li>Connect Panacea with existing enterprise systems, databases, and APIs to enable seamless data flow and functionality.</li> <li> <p>Utilize the Developer API for custom integrations and automation.</p> </li> <li> <p>Deploy Agents</p> </li> <li>Launch and manage agents within the private environment through the enterprise UI or API.</li> <li>Monitor agent performance and resource usage to ensure optimal operation.</li> </ol>"},{"location":"8_private_deployment.html#best-practices","title":"Best Practices","text":"<ul> <li>Data Encryption: Always encrypt sensitive data both at rest and in transit to safeguard against unauthorized access.</li> <li>Regular Audits: Conduct regular security audits and compliance checks to ensure adherence to industry standards.</li> <li>Backup and Recovery: Implement robust backup and disaster recovery plans to protect against data loss and ensure business continuity.</li> <li>Monitoring and Alerts: Utilize logging and monitoring tools to track system performance and receive alerts for any anomalies or issues.</li> <li>Scalability Planning: Design your deployment with scalability in mind, allowing for the addition of resources and agents as your organization grows.</li> </ul>"},{"location":"8_private_deployment.html#support","title":"Support","text":"<p>For assistance with private deployment, visit our Enterprise Support Center or contact our enterprise support team:</p> <ul> <li>Email: enterprise-support@panacea.ai</li> <li>Phone: +1 (800) 123-4567</li> </ul>"},{"location":"9_logging_and_monitoring.html","title":"Logging and Monitoring","text":"<p>Panacea incorporates robust logging and monitoring mechanisms to track the activities and performance of each agent. This transparency allows users to:</p> <ul> <li>Monitor Performance: Keep an eye on how each agent is performing its tasks.</li> <li>Debug Issues: Quickly identify and resolve any problems that arise.</li> <li>Optimize Workflows: Use insights from logs to refine and improve workflow processes continuously.</li> </ul>"},{"location":"9_logging_and_monitoring.html#logging-features","title":"Logging Features","text":"<ul> <li>Activity Logs: Detailed records of agent actions and task executions.</li> <li>Error Logs: Capture any errors or exceptions encountered by agents.</li> <li>Audit Trails: Maintain comprehensive audit trails for compliance and accountability.</li> </ul>"},{"location":"9_logging_and_monitoring.html#monitoring-tools","title":"Monitoring Tools","text":"<ul> <li>Real-Time Dashboards: Visualize agent performance metrics and system status.</li> <li>Alerts and Notifications: Receive alerts for critical issues, such as task failures or performance bottlenecks.</li> <li>Analytics Reports: Generate reports to analyze workflow efficiency and agent effectiveness.</li> </ul>"},{"location":"9_logging_and_monitoring.html#example-monitoring-dashboard-components","title":"Example Monitoring Dashboard Components","text":"<ul> <li>Agent Status: Current status of each agent (active, idle, busy, error).</li> <li>Task Overview: Summary of tasks in progress, completed, and failed.</li> <li>Performance Metrics: Data on task completion times, resource utilization, and success rates.</li> <li>System Health: Indicators of overall system health, including uptime and resource availability.</li> </ul>"},{"location":"9_logging_and_monitoring.html#accessing-logs-and-reports","title":"Accessing Logs and Reports","text":"<ul> <li>UI-Based Access: View logs and monitoring data directly within the Panacea UI.</li> <li>API Access: Retrieve logs and performance data programmatically through the Developer API.</li> <li>Export Options: Export logs and reports for offline analysis or integration with other monitoring tools.</li> </ul>"},{"location":"9_logging_and_monitoring.html#best-practices","title":"Best Practices","text":"<ul> <li>Centralized Logging: Aggregate logs from all agents into a centralized system for easier management and analysis.</li> <li>Regular Reviews: Periodically review logs and monitoring reports to identify trends and potential areas for improvement.</li> <li>Automated Alerts: Set up automated alerts for critical metrics to ensure prompt response to issues.</li> <li>Data Retention Policies: Define data retention policies to manage log storage efficiently while complying with regulatory requirements.</li> </ul>"},{"location":"9_logging_and_monitoring.html#tools-and-technologies","title":"Tools and Technologies","text":"<ul> <li>Prometheus: An open-source monitoring and alerting toolkit used for collecting and storing metrics.</li> <li>Grafana: A powerful data visualization tool that integrates with Prometheus to create interactive dashboards.</li> <li>ELK Stack (Elasticsearch, Logstash, Kibana): A suite of tools for centralized logging, data ingestion, and visualization.</li> <li>Nagios: A monitoring system that enables organizations to identify and resolve IT infrastructure problems.</li> <li>Datadog: A cloud-based monitoring and analytics platform for large-scale applications and infrastructure.</li> </ul>"},{"location":"9_logging_and_monitoring.html#implementation-highlights","title":"Implementation Highlights","text":"<ul> <li>Structured Logging: Use structured logging formats like JSON to facilitate easier parsing and analysis.</li> <li>Granular Metrics: Collect detailed metrics on agent performance, task execution times, and resource usage.</li> <li>Real-Time Monitoring: Implement real-time monitoring to detect and respond to issues promptly.</li> <li>Historical Analysis: Maintain historical logs and metrics to perform trend analysis and capacity planning.</li> </ul>"},{"location":"9_logging_and_monitoring.html#support","title":"Support","text":"<p>For assistance with logging and monitoring setup, visit our Support Center or contact our support team:</p> <ul> <li>Email: support@panacea.ai</li> <li>Phone: +1 (800) 123-4567</li> </ul>"},{"location":"api-endpoints/assign-task.html","title":"Assign Task","text":"<p>Assign a new task to an existing agent.</p> <p>Parameters:</p> Name Type Description Default <code>request_body</code> <code>dict</code> <p>JSON body with at least: - \"agent_id\": The ID of the agent to assign the task. - \"description\": The task description.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>Dict[str, Any]</code> <p>JSON response from the server, typically including task_id, agent_id, and status.</p> <p>Sample usage:</p> <p><pre><code>from anoteai import Anote\napi_key = 'INSERT_API_KEY_HERE'\nanote = Anote(api_key=api_key)\ntask_request = {\n\"agent_id\": 123,\n\"description\": \"Research the latest data on housing prices in San Francisco.\"\n}\nresponse = anote.assign_task(task_request)\nprint(response)\n</code></pre> Response (JSON):</p> <pre><code>{\n\"task_id\": 456,\n\"agent_id\": 123,\n\"description\": \"Research the latest data on housing prices in San Francisco.\",\n\"status\": \"assigned\"\n}\n</code></pre>"},{"location":"api-endpoints/chat.html","title":"Chat","text":"<p>Send a message to the chatbot based on documents previously uploaded.</p> <p>Parameters:</p> Name Type Description Default <code>chat_id</code> <code>int</code> <p>The ID of the chat that has had documents uploaded.</p> required <code>message</code> <code>str</code> <p>The message to send to the chatbot.</p> required <code>finetuned_model_key</code> <code>str</code> <p>An optional custom model OpenAI key. If provided, the chatbot uses this finetuned model for the response.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>response</code> <code>dict</code> <p>The JSON response from the API containing <code>answer</code>, <code>message_id</code> and <code>sources</code> (which contains the document name and the relevant chunk).</p> <p>Sample usage: <pre><code>from anoteai import Anote\napi_key = 'INSERT_API_KEY_HERE'\nAnote = Anote(api_key, isPrivate=False) #You can select isPrivate=True if you want to use private models\nchat_id = 5\nresponse = privategpt.chat(chat_id, \"What is this paper about?\", finetuned_model_key=\"ft:gpt-35-turbo-0613:personal:anote:8DO8V2LB\")\n</code></pre></p> <p>Response is given as a JSON in this format: <pre><code>{\n'answer': 'The paper on classification performance is about utilizing few-shot and active learning to enhance artificial intelligence models.,\n'message_id': 10,\n'sources': [\n['doc2.pdf', 'To address this, we delve into few-shot and active learning, where our goal is to improve AI models with human feedback.'],\n['doc1.pdf', 'Improving Classification Performance With Human Feedback: \\n\\Label a few, we label the rest']\n]\n}\n</code></pre></p>"},{"location":"api-endpoints/create-agent.html","title":"Create Agent","text":"<p>Create Agent </p> <p>Create an agent with the given configuration.</p> <p>Parameters:</p> Name Type Description Default <code>request_body</code> <code>dict</code> <p>JSON body containing agent details.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>Dict[str, Any]</code> <p>JSON response from the server, typically including agent_id and status.</p> <p>Sample usage:</p> <p><pre><code>from anoteai import Anote\napi_key = 'INSERT_API_KEY_HERE'\nanote = Anote(api_key=api_key)\nrequest_body = {\n\"type\": \"WebSurferAgent\",\n\"config\": {\n\"search_criteria\": {\n\"role\": \"Data Scientist\",\n\"location\": \"San Francisco\"\n}\n}\n}\nresponse = anote.create_agent(request_body)\nprint(response)\n</code></pre> Response (JSON):</p> <pre><code>{\n\"agent_id\": 123,\n\"status\": \"created\",\n\"type\": \"WebSurferAgent\",\n\"config\": {\n\"search_criteria\": {\n\"role\": \"Data Scientist\",\n\"location\": \"San Francisco\"\n}\n}\n}\n</code></pre>"},{"location":"api-endpoints/delete-agent.html","title":"Delete Agent","text":"<p>Delete an existing agent by ID.</p> <p>Parameters:</p> Name Type Description Default <code>agent_id</code> <code>int</code> <p>The ID of the agent to delete.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>Dict[str, Any]</code> <p>JSON response confirming the deletion status.</p> <p>Sample usage:</p> <pre><code>from anoteai import Anote\napi_key = 'INSERT_API_KEY_HERE'\nanote = Anote(api_key=api_key)\nagent_id = 123\nresponse = anote.delete_agent(agent_id)\nprint(response)\nResponse (JSON):\n</code></pre> <pre><code>{\n\"agent_id\": 123,\n\"status\": \"deleted\"\n}\n</code></pre>"},{"location":"api-endpoints/evaluate.html","title":"Evaluate","text":"<p>Evaluate predictions on one or multiple documents/text.</p> <p>Parameters:</p> Name Type Description Default <code>message_id</code> <code>str</code> <p>The ID of the message associated with the uploaded documents. This ID is used to identify which set of documents/text predictions should be evaluated.</p> required <p>Returns:</p> Name Type Description <code>response</code> <code>dict</code> <p>A JSON response from the API, containing the evaluation results, <code>answer_relevancy</code>, <code>faithfulness</code> of the predictions on the specified message's documents or text. If the message ID is not provided or invalid, the function returns an error message indicating that a valid message ID is required for the operation.</p> <p>Sample usage: <pre><code>from anoteai import Anote\napi_key = 'INSERT_API_KEY_HERE'\nAnote = Anote(api_key, isPrivate=False) #You can select isPrivate=True if you want to use private models\nmessage_id = 5\nresponse = privategpt.evaluate(message_id)\n</code></pre></p> <p>Response is given as a JSON in this format: <pre><code>{\n'answer_relevancy': 0.88,\n'faithfulness': 1.0\n}\n</code></pre></p>"},{"location":"api-endpoints/finetune.html","title":"Fine Tune","text":"<p>Train or Fine Tune a model via supervised, unsupervised or rlhf fine tuning</p> <p>Parameters:</p> Name Type Description Default <code>model_name</code> <code>str</code> <p>The name of the model - which is referenced in the model_ids table alongside the model_id.</p> required <code>model_type</code> <code>str</code> <p>Model that is used to do the fine tuning - could be \"FT-GPT\", \"Llama3\" for supervised, \"MLM\" for unsupervised.</p> <code>FTGPT</code> <code>fine_tuning_type</code> <code>str</code> <p>The type of fine tuning - could be \"supervised\", \"unsupervised\" or \"rlhf\"</p> required <code>x_train_csv</code> <code>DataFrame</code> <p>training data for fine tuning (string is csv of file path)- for each row could contain question or context entries</p> required <code>y_train_csv</code> <code>DataFrame</code> <p>training labels for fine tuning (string is csv of file path) - for each row could contain answer entries</p> required <code>initial_model_id</code> <code>str</code> <p>if rlhf fine tuning type, can add initial unsupervised model id from pretraining step for transfer learning</p> required <code>document_files</code> <code>list[str]</code> <p>A list of file paths to documents for document-based tasks for training. Example: ['path/to/file1.pdf', 'path/to/file2.pdf'].</p> required <p>Returns:</p> Name Type Description <code>response</code> <code>dict</code> <p>A JSON response from the API, including the <code>model_id</code> of the trained model.</p>"},{"location":"api-endpoints/get-task-status.html","title":"Get Task Status","text":"<p>Retrieve the status of a given task.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>int</code> <p>The ID of the task.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>Dict[str, Any]</code> <p>JSON response containing current status, progress details, etc.</p> <p>Sample usage:</p> <p><pre><code>from anoteai import Anote\napi_key = 'INSERT_API_KEY_HERE'\nanote = Anote(api_key=api_key)\ntask_id = 456\nresponse = anote.get_task_status(task_id)\nprint(response)\n</code></pre> Response (JSON):</p> <pre><code>{\n\"task_id\": 456,\n\"status\": \"in_progress\",\n\"progress_details\": {\n\"current_step\": 2,\n\"total_steps\": 5\n},\n\"result\": null\n}\n</code></pre>"},{"location":"api-endpoints/list-agents.html","title":"List Agents","text":"<p>List all agents currently registered in the system.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>dict or list: JSON response with a list of agents (each agent may have fields like agent_id, type, status).</p> <p>Sample usage:</p> <p><pre><code>from anoteai import Anote\napi_key = 'INSERT_API_KEY_HERE'\nanote = Anote(api_key=api_key)\nresponse = anote.list_agents()\nprint(response)\n</code></pre> Response (JSON):</p> <pre><code>[\n{\n\"agent_id\": 123,\n\"type\": \"WebSurferAgent\",\n\"status\": \"active\"\n},\n{\n\"agent_id\": 124,\n\"type\": \"FinanceAgent\",\n\"status\": \"idle\"\n}\n]\n</code></pre>"},{"location":"api-endpoints/predict.html","title":"Predict","text":"<p>Make predictions based on a fine tuned model or default model.</p> <p>Parameters:</p> Name Type Description Default <code>model_name</code> <code>str</code> <p>The name of the model - which is referenced in the model_ids table alongside the model_id.</p> required <code>model_id</code> <code>str</code> <p>The model id that is the output of the train API call - enables fine tuned models to be called.</p> required <code>question_text</code> <code>str</code> <p>A string that contains the question.</p> required <code>context_text</code> <code>str</code> <p>A string that contains additional text that can be concatenated to the question, if needed.</p> <code>None</code> <code>document_files</code> <code>list[str]</code> <p>A list of file paths to documents for document-based tasks for predictions. Example: ['path/to/file1.pdf', 'path/to/file2.pdf'].</p> <code>None</code> <p>Returns:</p> Name Type Description <code>response</code> <code>dict</code> <p>A JSON response from the API, including the <code>results</code> of the predictions.</p>"},{"location":"api-endpoints/upload-private.html","title":"Upload - Private","text":"<p>Upload documents or specify a ticker for data retrieval and Q&amp;A. This method supports various tasks, such as uploading documents or querying the government's EDGAR database.</p> <p>Parameters:</p> Name Type Description Default <code>task_type</code> <code>str</code> <p>Specifies the type of task to perform. This can be document-based interaction (e.g., 'documents') or financial data analysis ('edgar').</p> required <code>model_type</code> <code>str</code> <p>Determines the AI model to use for processing the request. Different model types available are 'llama' for LLaMa2 and 'mistral' for Mistral.</p> required <code>ticker</code> <code>str</code> <p>The ticker symbol for financial data analysis tasks. Required if the task_type is 'edgar'. Example: 'AAPL' for Apple Inc.</p> <code>None</code> <code>file_paths</code> <code>list[str]</code> <p>A list of file paths to documents for document-based tasks. Required if task_type is 'documents'. Example: ['path/to/file1.pdf', 'path/to/file2.pdf'].</p> <code>None</code> <p>Returns:</p> Name Type Description <code>response</code> <code>dict</code> <p>A JSON response from the API, including the <code>chat_id</code> for interactions based on the uploaded content or specified ticker.</p> <p>Sample usage for uploading documents: <pre><code>from anoteai import Anote\napi_key = 'INSERT_API_KEY_HERE'\nAnote = Anote(api_key, isPrivate=True)\nfile_paths = ['doc1.pdf', 'doc2.pdf']\nresponse = Anote.upload(task_type=\"documents\", model_type=\"llama\", file_paths=file_paths)\n</code></pre></p> <p>Response is given as a JSON in this format: <pre><code>{\n\"id\": 5\n}\n</code></pre></p> <p>Sample usage for using Edgar: <pre><code>from anoteai import Anote\napi_key = 'INSERT_API_KEY_HERE'\nAnote = Anote(api_key, isPrivate=True)\nresponse = Anote.upload(task_type=\"edgar\", model_type=\"llama\", ticker=\"aapl\")\n</code></pre> Response is given as a JSON in this format: <pre><code>{\n\"id\": 5\n}\n</code></pre></p>"},{"location":"api-endpoints/upload.html","title":"Upload - Public","text":"<p>Upload documents or specify a ticker for data retrieval and Q&amp;A. This method supports various tasks, such as uploading documents or querying the government's EDGAR database.</p> <p>Parameters:</p> Name Type Description Default <code>task_type</code> <code>str</code> <p>Specifies the type of task to perform. This can be document-based interaction (e.g., 'documents') or financial data analysis ('edgar').</p> required <code>model_type</code> <code>str</code> <p>Determines the AI model to use for processing the request. Different model types available are 'gpt' for GPT-4 and 'claude' for Claude.</p> required <code>ticker</code> <code>str</code> <p>The ticker symbol for financial data analysis tasks. Required if the task_type is 'edgar'. Example: 'AAPL' for Apple Inc.</p> <code>None</code> <code>file_paths</code> <code>list[str]</code> <p>A list of file paths to documents for document-based tasks. Required if task_type is 'documents'. Example: ['path/to/file1.pdf', 'path/to/file2.pdf'].</p> <code>None</code> <p>Returns:</p> Name Type Description <code>response</code> <code>dict</code> <p>A JSON response from the API, including the <code>chat_id</code> for interactions based on the uploaded content or specified ticker.</p> <p>Sample usage for uploading documents: <pre><code>from anoteai import Anote\napi_key = 'INSERT_API_KEY_HERE'\nAnote = Anote(api_key, isPrivate=False)\nfile_paths = ['doc1.pdf', 'doc2.pdf']\nresponse = Anote.upload(task_type=\"documents\", model_type=\"gpt\", file_paths=file_paths)\n</code></pre></p> <p>Response is given as a JSON in this format: <pre><code>{\n\"id\": 5\n}\n</code></pre></p> <p>Sample usage for using Edgar: <pre><code>from anoteai import Anote\napi_key = 'INSERT_API_KEY_HERE'\nAnote = Anote(api_key, isPrivate=False)\nresponse = Anote.upload(task_type=\"edgar\", model_type=\"claude\", ticker=\"aapl\")\n</code></pre> Response is given as a JSON in this format: <pre><code>{\n\"id\": 5\n}\n</code></pre></p>"},{"location":"api-overview/agent.html","title":"Agents","text":"<p>An Agent is an autonomous unit designed to perform tasks, make decisions, and possibly interact with other Agents. Agents can be specialized by role or configured for different goals.</p> <p>Represents an AI-driven entity, configured with a model and optional default Task.</p> Source code in <code>fsdk/anote-sdk.py</code> <pre><code>class Agent:\n\"\"\"\n    Represents an AI-driven entity, configured with a model and optional default Task.\n    \"\"\"\ndef __init__(\nself,\nname: str,\nmodel: str,\nsystem_prompt: str,\ntask: Optional[\"Task\"] = None,\ntools: Optional[List[str]] = None,\nverbose: bool = False\n):\n\"\"\"\n        Args:\n            name (str): Short identifier for the agent (e.g., 'FinanceAgent').\n            model (str): Underlying LLM (e.g., 'gpt4', 'gpt3.5turbo', 'llama').\n            system_prompt (str): A top-level prompt or role instruction (e.g., 'You are an event planner.').\n            task (Task, optional): A default Task object this Agent is responsible for.\n            tools (list of str, optional): Names of tools the Agent can call (e.g., 'ScrapeWebsiteTool').\n            verbose (bool): If True, logs extra debug info.\n        \"\"\"\nself.name = name\nself.model = model\nself.system_prompt = system_prompt\nself.task = task\nself.tools = tools or []\nself.verbose = verbose\ndef __repr__(self):\nreturn f\"&lt;Agent name={self.name} model={self.model} verbose={self.verbose}&gt;\"\n</code></pre>"},{"location":"api-overview/agent.html#fsdk.anote-sdk.Agent.__init__","title":"<code>__init__(name, model, system_prompt, task=None, tools=None, verbose=False)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Short identifier for the agent (e.g., 'FinanceAgent').</p> required <code>model</code> <code>str</code> <p>Underlying LLM (e.g., 'gpt4', 'gpt3.5turbo', 'llama').</p> required <code>system_prompt</code> <code>str</code> <p>A top-level prompt or role instruction (e.g., 'You are an event planner.').</p> required <code>task</code> <code>Task</code> <p>A default Task object this Agent is responsible for.</p> <code>None</code> <code>tools</code> <code>list of str</code> <p>Names of tools the Agent can call (e.g., 'ScrapeWebsiteTool').</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>If True, logs extra debug info.</p> <code>False</code> Source code in <code>fsdk/anote-sdk.py</code> <pre><code>def __init__(\nself,\nname: str,\nmodel: str,\nsystem_prompt: str,\ntask: Optional[\"Task\"] = None,\ntools: Optional[List[str]] = None,\nverbose: bool = False\n):\n\"\"\"\n    Args:\n        name (str): Short identifier for the agent (e.g., 'FinanceAgent').\n        model (str): Underlying LLM (e.g., 'gpt4', 'gpt3.5turbo', 'llama').\n        system_prompt (str): A top-level prompt or role instruction (e.g., 'You are an event planner.').\n        task (Task, optional): A default Task object this Agent is responsible for.\n        tools (list of str, optional): Names of tools the Agent can call (e.g., 'ScrapeWebsiteTool').\n        verbose (bool): If True, logs extra debug info.\n    \"\"\"\nself.name = name\nself.model = model\nself.system_prompt = system_prompt\nself.task = task\nself.tools = tools or []\nself.verbose = verbose\n</code></pre>"},{"location":"api-overview/agent.html#agents-fields","title":"Agents Fields","text":"<ul> <li>name: Short identifier for the Agent (e.g., <code>\"FinanceAgent\"</code>).</li> <li>model: Underlying LLM (e.g., <code>\"gpt4\"</code>, <code>\"gpt3.5turbo\"</code>, <code>\"llama\"</code>).</li> <li>system_prompt: A top-level prompt or role instruction (e.g., <code>\"You are an event planner.\"</code>).</li> <li>task: A default Task this Agent is responsible for (optional).</li> <li>tools: Names of tools the Agent can call (e.g., <code>\"ScrapeWebsiteTool\"</code>).</li> <li>verbose: If <code>True</code>, logs extra debug info.</li> </ul> <p>Example: <pre><code>from anote_agents import Agent\nagent = Agent(\nname=\"FinanceAgent\",\nmodel=\"gpt4\",\nsystem_prompt=\"You analyze financial data.\",\ntask=None,\ntools=[\"SerperDevTool\", \"ScrapeWebsiteTool\"],\nverbose=True\n)\n</code></pre></p> <p>Agents can autonomously execute tasks, leverage tools to gather information or take actions, and collaborate with other agents within a crew.</p> <p>Example 2:</p> <p><pre><code>from anote_agents import Agent\ncustomer_support_agent = Agent(\nrole=\"Customer Support Agent\",\ngoal=\"Assist users with common troubleshooting steps\",\ntools=[],\nverbose=True,\nbackstory=\"You are friendly and patient, helping customers find solutions.\"\n)\n</code></pre> By defining Agents carefully, you ensure they remain focused on their intended purpose and handle tasks efficiently.</p>"},{"location":"api-overview/crews.html","title":"Crews","text":"<p>A Crew is a group of Agents executing one or more Tasks in a coordinated manner.</p> <p>Represents a collaborative group of Agents and the Tasks they must complete.</p> Source code in <code>fsdk/anote-sdk.py</code> <pre><code>class Crew:\n\"\"\"\n    Represents a collaborative group of Agents and the Tasks they must complete.\n    \"\"\"\ndef __init__(\nself,\nagents: Optional[List[Agent]] = None,\ntasks: Optional[List[Task]] = None,\nverbose: bool = False\n):\n\"\"\"\n        Args:\n            agents (list of Agent, optional): Agents that will collaborate on Tasks.\n            tasks (list of Task, optional): Tasks to be completed by these Agents.\n            verbose (bool): If True, logs more details during execution.\n        \"\"\"\nself.agents = agents or []\nself.tasks = tasks or []\nself.verbose = verbose\ndef __repr__(self):\nreturn f\"&lt;Crew agents={len(self.agents)} tasks={len(self.tasks)} verbose={self.verbose}&gt;\"\ndef kickoff(self, inputs: Dict[str, Any] = None):\n\"\"\"\n        Starts or orchestrates the tasks in some manner.\n        Customize as needed for your logic (sequential, parallel, hierarchical, etc.).\n        \"\"\"\nif self.verbose:\nprint(f\"[Crew] Kicking off with inputs: {inputs}\")\n# Example: Just prints out each task's instructions\nfor task in self.tasks:\nif self.verbose:\nprint(f\"[Crew] Running task: {task.instructions}\")\nreturn {\"status\": \"completed\", \"inputs_used\": inputs}\n</code></pre>"},{"location":"api-overview/crews.html#fsdk.anote-sdk.Crew.__init__","title":"<code>__init__(agents=None, tasks=None, verbose=False)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>agents</code> <code>list of Agent</code> <p>Agents that will collaborate on Tasks.</p> <code>None</code> <code>tasks</code> <code>list of Task</code> <p>Tasks to be completed by these Agents.</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>If True, logs more details during execution.</p> <code>False</code> Source code in <code>fsdk/anote-sdk.py</code> <pre><code>def __init__(\nself,\nagents: Optional[List[Agent]] = None,\ntasks: Optional[List[Task]] = None,\nverbose: bool = False\n):\n\"\"\"\n    Args:\n        agents (list of Agent, optional): Agents that will collaborate on Tasks.\n        tasks (list of Task, optional): Tasks to be completed by these Agents.\n        verbose (bool): If True, logs more details during execution.\n    \"\"\"\nself.agents = agents or []\nself.tasks = tasks or []\nself.verbose = verbose\n</code></pre>"},{"location":"api-overview/crews.html#fsdk.anote-sdk.Crew.kickoff","title":"<code>kickoff(inputs=None)</code>","text":"<p>Starts or orchestrates the tasks in some manner. Customize as needed for your logic (sequential, parallel, hierarchical, etc.).</p> Source code in <code>fsdk/anote-sdk.py</code> <pre><code>def kickoff(self, inputs: Dict[str, Any] = None):\n\"\"\"\n    Starts or orchestrates the tasks in some manner.\n    Customize as needed for your logic (sequential, parallel, hierarchical, etc.).\n    \"\"\"\nif self.verbose:\nprint(f\"[Crew] Kicking off with inputs: {inputs}\")\n# Example: Just prints out each task's instructions\nfor task in self.tasks:\nif self.verbose:\nprint(f\"[Crew] Running task: {task.instructions}\")\nreturn {\"status\": \"completed\", \"inputs_used\": inputs}\n</code></pre>"},{"location":"api-overview/crews.html#crews-fields","title":"Crews Fields","text":"<ul> <li>agents: All the Agents that will collaborate (list of Agent objects).</li> <li>tasks: The tasks to be completed by these Agents (list of Task objects).</li> <li>verbose: If <code>True</code>, logs more details during execution.</li> </ul> <p>Example:</p> <pre><code>from anote_agents import Crew\ncrew = Crew(\nagents=[venue_coordinator, logistics_manager],\ntasks=[venue_task, logistics_task],\nverbose=True\n)\n</code></pre>"},{"location":"api-overview/crews.html#composition","title":"Composition","text":"<p>Crews can be composed of: - Multiple Agents (e.g., marketing agent, finance agent, research agent) - One or more Tasks (e.g., \"Conduct market research,\" \"Prepare financial analysis\")</p>"},{"location":"api-overview/crews.html#execution-flow","title":"Execution Flow","text":"<p>Initialization: The Crew binds each Task to the correct Agent. kickoff: Passes input data (if any) into tasks that contain placeholders. Orchestration: Tasks may run sequentially or in parallel, depending on workflow. Results: The Crew collects outputs from each Task.</p> <p>Example 2:</p> <pre><code>from anote_agents import Crew\nteam_crew = Crew(\nagents=[marketing_agent, finance_agent],\ntasks=[research_task, analysis_task],\nverbose=True\n)\n# Kick off the tasks\nresults = team_crew.kickoff(inputs={\"industry\": \"Renewable Energy\"})\n</code></pre>"},{"location":"api-overview/crews.html#key-benefits","title":"Key Benefits","text":"<ul> <li>Centralized management for complex multi-agent workflows.</li> <li>Clear separation of responsibilities among Agents.</li> <li>Reusability of Agents and Tasks across different Crews if desired.</li> </ul>"},{"location":"api-overview/setup.html","title":"Overview","text":"<p>The Agents API is a software developer kit designed for developers to leverage LLMs to build teams of agents, and have them collaborate of doing tasks.</p>"},{"location":"api-overview/setup.html#setup","title":"Setup","text":"<p>This setup guide is designed to help get your local development environment setup and send your first API request. Throughout this guide, you will learn:</p> <ul> <li>How to setup your Anote account</li> <li>How to install the Agents Python Pip Package</li> <li>How to send your first Agents API request</li> </ul>"},{"location":"api-overview/setup.html#step-1-account-setup","title":"Step 1: Account setup","text":"<p>First, create an Anote account or sign in. Next, navigate to the API key page and press the Create new API key button to generate a new API key.</p> <p></p> <p>Copy the API key, and make sure to save this somewhere safe and do not share it with anyone.</p>"},{"location":"api-overview/setup.html#step-2-installing-python-pip-package","title":"Step 2: Installing Python Pip Package","text":"<p>To use the Anote Python library, you need to have Python installed. To ensure you have Python installed, navigate to your Terminal or Command line:</p> <ul> <li> <p>MacOS: Open Terminal: You can find it in the Applications folder or search for it using Spotlight (Command + Space).</p> </li> <li> <p>Windows: Open Command Prompt: You can find it by searching \"cmd\" in the start menu.</p> </li> </ul> <p>Next, enter <code>python3 --version</code> and then press enter, to ensure you see a python version &gt;3.7.</p> <p>To install the Private Chatbot Python library from the terminal / command line, run: <pre><code>pip install -U anoteagents\n</code></pre></p>"},{"location":"api-overview/setup.html#step-3-sending-your-first-api-request","title":"Step 3: Sending your first API request","text":"<p>After you have Python configured and set up an API key, the final step is to send a request to the Anote API using the Python library. To do this, create a file named anote-test.py using the terminal or an IDE.</p> <p>Inside the file, copy and paste the example below: <pre><code>from anote-agents import Anote\napi_key = 'INSERT_API_KEY_HERE'\n</code></pre> You should obtain an agent object.</p>"},{"location":"api-overview/setup.html#bringing-it-all-together","title":"Bringing It All Together","text":"<p><pre><code>from anote-agents import Agent, Task, Crew, Workflow, Tools\napi_key = 'INSERT_API_KEY_HERE'\n# Simple end-to-end example\n# 1) Define an Agent\ncoordinator = Agent(\nname=\"VenueCoordinator\",\nmodel=\"gpt3.5turbo\",\nsystem_prompt=\"You book event venues in San Francisco.\",\ntools=[\"ScrapeWebsiteTool\"],\nverbose=True\n)\n# 2) Create a Task for that Agent\nvenue_task = Task(\ninstructions=\"Find a venue for 500 attendees with a budget of $5000.\",\nfiles_uploaded=[],\nexpected_output=\"Brief JSON with venue name, location, cost, capacity.\",\nagent=coordinator\n)\n# 3) Build a Crew\nevent_crew = Crew(\nagents=[coordinator],\ntasks=[venue_task],\nverbose=True\n)\n# 4) (Optional) Configure a Workflow\nmy_workflow = {\n\"workflow_type\": \"sequential\",\n\"manager_agent\": None,\n\"allow_parallel\": False\n}\n# In practice, you'd integrate this workflow config into the Crew logic.\n</code></pre> Key Points: A Tool is typically implemented in Python, but from the Agent\u2019s perspective it\u2019s just a string reference.</p> <pre><code>[CREW] Kicking off tasks...\n[VenueCoordinator] Task Instructions: Find a venue for 500 attendees with a budget of $5000.\n[VenueCoordinator] Using tools: ['ScrapeWebsiteTool']\n[VenueCoordinator] Found a suitable venue under $5000!\nTask Result: {\n  \"venue_name\": \"Bayview Conference Center\",\n  \"location\": \"San Francisco\",\n  \"cost\": 4000,\n  \"capacity\": 500\n}\nCrew Execution Completed. All tasks processed.\n</code></pre>"},{"location":"api-overview/task.html","title":"Tasks","text":"<p>A Task is a discrete assignment or job for an Agent to execute. Tasks contain a description of the work, expected output, optional input requirements, and references to tools or data.</p> <p>Represents a discrete assignment or objective for an Agent.</p> Source code in <code>fsdk/anote-sdk.py</code> <pre><code>class Task:\n\"\"\"\n    Represents a discrete assignment or objective for an Agent.\n    \"\"\"\ndef __init__(\nself,\ninstructions: str,\nfiles_uploaded: Optional[List[str]] = None,\nexamples: Optional[List[str]] = None,\nexpected_output: str = \"\",\nagent: Optional[Agent] = None\n):\n\"\"\"\n        Args:\n            instructions (str): The main prompt or directive for the Agent.\n            files_uploaded (list of str, optional): File paths or IDs relevant to the Task (e.g., PDFs, CSVs).\n            examples (list, optional): Few-shot examples or reference data.\n            expected_output (str): Form or content of the final result (e.g., 'Return a markdown summary').\n            agent (Agent, optional): The Agent assigned to this Task.\n        \"\"\"\nself.instructions = instructions\nself.files_uploaded = files_uploaded or []\nself.examples = examples or []\nself.expected_output = expected_output\nself.agent = agent\ndef __repr__(self):\nreturn f\"&lt;Task instructions={self.instructions[:25]}... expected_output={self.expected_output[:25]}...&gt;\"\n</code></pre>"},{"location":"api-overview/task.html#fsdk.anote-sdk.Task.__init__","title":"<code>__init__(instructions, files_uploaded=None, examples=None, expected_output='', agent=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>instructions</code> <code>str</code> <p>The main prompt or directive for the Agent.</p> required <code>files_uploaded</code> <code>list of str</code> <p>File paths or IDs relevant to the Task (e.g., PDFs, CSVs).</p> <code>None</code> <code>examples</code> <code>list</code> <p>Few-shot examples or reference data.</p> <code>None</code> <code>expected_output</code> <code>str</code> <p>Form or content of the final result (e.g., 'Return a markdown summary').</p> <code>''</code> <code>agent</code> <code>Agent</code> <p>The Agent assigned to this Task.</p> <code>None</code> Source code in <code>fsdk/anote-sdk.py</code> <pre><code>def __init__(\nself,\ninstructions: str,\nfiles_uploaded: Optional[List[str]] = None,\nexamples: Optional[List[str]] = None,\nexpected_output: str = \"\",\nagent: Optional[Agent] = None\n):\n\"\"\"\n    Args:\n        instructions (str): The main prompt or directive for the Agent.\n        files_uploaded (list of str, optional): File paths or IDs relevant to the Task (e.g., PDFs, CSVs).\n        examples (list, optional): Few-shot examples or reference data.\n        expected_output (str): Form or content of the final result (e.g., 'Return a markdown summary').\n        agent (Agent, optional): The Agent assigned to this Task.\n    \"\"\"\nself.instructions = instructions\nself.files_uploaded = files_uploaded or []\nself.examples = examples or []\nself.expected_output = expected_output\nself.agent = agent\n</code></pre>"},{"location":"api-overview/task.html#tasks-fields","title":"Tasks Fields","text":"<ul> <li>instructions: The main prompt or directive (e.g., <code>\"Summarize Q3 earnings\"</code>).</li> <li>files_uploaded: File paths or IDs relevant to the Task (e.g., <code>[\"report_Q3_2023.pdf\"]</code>).</li> <li>examples: Optional few-shot examples or reference data.</li> <li>expected_output: The form or content of the final result (e.g., <code>\"Return a markdown summary\"</code>).</li> <li>agent: The Agent to which this Task is assigned.</li> </ul> <p>Example:</p> <pre><code>from anote_agents import Task\ntask = Task(\ninstructions=\"Summarize the Q3 earnings from the attached PDF.\",\nfiles_uploaded=[\"report_Q3_2023.pdf\"],\nexamples=[\"In Q2, we saw a 12% increase in revenue...\"],\nexpected_output=\"Short text summary with key figures.\",\nagent=None\n)\n</code></pre>"},{"location":"api-overview/task.html#examples-of-task-usage","title":"Examples of Task Usage","text":"<p>Scheduling: \u201cFind the best meeting times with {participant_count} participants.\u201d Research: \u201cGather references on quantum computing breakthroughs since 2020.\u201d</p> <p>If using structured outputs, define output_json for validation and type safety.</p> <p>Example 2:</p> <pre><code>from anote_agents import Task\ndata_analysis_task = Task(\ndescription=\"Analyze historical sales data for the past 3 years\",\nexpected_output=\"A summary of key sales trends, plus any anomalies found.\",\nhuman_input=False,\nagent=None  # Agent can be assigned later\n)\n</code></pre>"},{"location":"api-overview/tools.html","title":"Tools","text":"<p>Tools extend the capabilities of an Agent, allowing it to perform specialized actions\u2014like web searches, website scraping, or data lookups.</p> <p>Represents an external capability or integration (e.g., web search, data fetch).</p> Source code in <code>fsdk/anote-sdk.py</code> <pre><code>class Tools:\n\"\"\"\n    Represents an external capability or integration (e.g., web search, data fetch).\n    \"\"\"\ndef __init__(\nself,\ntool_name: str,\nconfig: Optional[Dict[str, Any]] = None\n):\n\"\"\"\n        Args:\n            tool_name (str): Identifier for the tool (e.g., 'ScrapeWebsiteTool').\n            config (dict, optional): Configuration details (e.g., API keys, parameters).\n        \"\"\"\nself.tool_name = tool_name\nself.config = config or {}\ndef __repr__(self):\nreturn f\"&lt;Tool tool_name={self.tool_name}&gt;\"\n</code></pre>"},{"location":"api-overview/tools.html#fsdk.anote-sdk.Tools.__init__","title":"<code>__init__(tool_name, config=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>tool_name</code> <code>str</code> <p>Identifier for the tool (e.g., 'ScrapeWebsiteTool').</p> required <code>config</code> <code>dict</code> <p>Configuration details (e.g., API keys, parameters).</p> <code>None</code> Source code in <code>fsdk/anote-sdk.py</code> <pre><code>def __init__(\nself,\ntool_name: str,\nconfig: Optional[Dict[str, Any]] = None\n):\n\"\"\"\n    Args:\n        tool_name (str): Identifier for the tool (e.g., 'ScrapeWebsiteTool').\n        config (dict, optional): Configuration details (e.g., API keys, parameters).\n    \"\"\"\nself.tool_name = tool_name\nself.config = config or {}\n</code></pre>"},{"location":"api-overview/tools.html#tools-fields","title":"Tools Fields","text":"<ul> <li>tool_name: Identifier for the Tool (e.g., <code>\"ScrapeWebsiteTool\"</code>).</li> <li>config: Configuration details (e.g., API keys, search parameters) (optional).</li> </ul> <p>Example:</p> <pre><code>from anote_agents import Agent\n# Agent referencing two tools by name\nagent_with_tools = Agent(\nname=\"ResearchAgent\",\nmodel=\"gpt3.5turbo\",\nsystem_prompt=\"You are skilled at finding online resources.\",\ntools=[\"SerperDevTool\", \"ScrapeWebsiteTool\"],\nverbose=False\n)\n</code></pre> <p>Tools They act as plugins or external functions the Agent can call.</p> <p>Example 2: <pre><code>from anote_agents.tools import SerperDevTool\nsearch_tool = SerperDevTool()\n# Provides web search functionality\n# Typically requires an API key or developer token\n</code></pre></p> <p>1.2 ScrapeWebsiteTool <pre><code>from anote_agents.tools import ScrapeWebsiteTool\nscrape_tool = ScrapeWebsiteTool()\n# Allows Agents to fetch and parse HTML from websites\n# Assigning Tools to Agents\nvenue_coordinator.tools = [search_tool, scrape_tool]\n</code></pre></p>"},{"location":"api-overview/tools.html#building-custom-tools","title":"Building Custom Tools","text":"<p>You can implement custom Tools (e.g., database queries, Slack bot actions) by extending a base Tool class and overriding a run() method. This approach unifies external integrations under a single interface.</p>"},{"location":"api-overview/workflows.html","title":"Workflows","text":"<p>Workflows dictate how Tasks are executed within a Crew. They define the order, logic, and decision-making structure.</p> <p>Defines the method by which tasks are executed within a Crew.</p> Source code in <code>fsdk/anote-sdk.py</code> <pre><code>class Workflow:\n\"\"\"\n    Defines the method by which tasks are executed within a Crew.\n    \"\"\"\ndef __init__(\nself,\nworkflow_type: str = \"sequential\",\nmanager_agent: Optional[Agent] = None,\nallow_parallel: bool = False\n):\n\"\"\"\n        Args:\n            workflow_type (str): e.g., 'sequential', 'hierarchical', or 'parallel'.\n            manager_agent (Agent, optional): Used in hierarchical workflows.\n            allow_parallel (bool): If True, tasks may run concurrently.\n        \"\"\"\nself.workflow_type = workflow_type\nself.manager_agent = manager_agent\nself.allow_parallel = allow_parallel\ndef __repr__(self):\nreturn (f\"&lt;Workflow type={self.workflow_type} \"\nf\"manager_agent={self.manager_agent} \"\nf\"allow_parallel={self.allow_parallel}&gt;\")\n</code></pre> <p>Description: Workflows define how Tasks are executed within a Crew. Common patterns include:</p>"},{"location":"api-overview/workflows.html#fsdk.anote-sdk.Workflow.__init__","title":"<code>__init__(workflow_type='sequential', manager_agent=None, allow_parallel=False)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>workflow_type</code> <code>str</code> <p>e.g., 'sequential', 'hierarchical', or 'parallel'.</p> <code>'sequential'</code> <code>manager_agent</code> <code>Agent</code> <p>Used in hierarchical workflows.</p> <code>None</code> <code>allow_parallel</code> <code>bool</code> <p>If True, tasks may run concurrently.</p> <code>False</code> Source code in <code>fsdk/anote-sdk.py</code> <pre><code>def __init__(\nself,\nworkflow_type: str = \"sequential\",\nmanager_agent: Optional[Agent] = None,\nallow_parallel: bool = False\n):\n\"\"\"\n    Args:\n        workflow_type (str): e.g., 'sequential', 'hierarchical', or 'parallel'.\n        manager_agent (Agent, optional): Used in hierarchical workflows.\n        allow_parallel (bool): If True, tasks may run concurrently.\n    \"\"\"\nself.workflow_type = workflow_type\nself.manager_agent = manager_agent\nself.allow_parallel = allow_parallel\n</code></pre>"},{"location":"api-overview/workflows.html#workflows-fields","title":"Workflows Fields","text":"<ul> <li>workflow_type: e.g., <code>\"sequential\"</code>, <code>\"hierarchical\"</code>, or <code>\"parallel\"</code>.</li> <li>manager_agent: Used in hierarchical workflows (Agent object, optional).</li> <li>allow_parallel: If <code>True</code>, tasks may run concurrently.</li> </ul> <p>Example:</p> <pre><code>workflow_example = {\n\"workflow_type\": \"sequential\",\n\"manager_agent\": None,\n\"allow_parallel\": False\n}\n</code></pre>"},{"location":"api-overview/workflows.html#1-common-workflow-types","title":"1. Common Workflow Types","text":"<ol> <li> <p>Sequential: Tasks run one after another in a predefined order. Good for simple, linear processes.</p> </li> <li> <p>Hierarchical: Involves a \"manager\" agent that oversees or delegates Tasks to subordinate agents. Useful when tasks must be dynamically created or delegated.</p> </li> <li> <p>Consensual (Planned): Focuses on collaborative decision-making among agents. Agents vote or debate to reach a consensus.</p> </li> </ol> <p>Example 2: <pre><code>crew = Crew(\nagents=[manager_agent, worker_agent],\ntasks=[task1, task2],\nverbose=True\n)\n# For hierarchical, specify a manager agent with special logic\ncrew.workflow_type = \"hierarchical\"\n</code></pre></p>"},{"location":"api-qa/example1.html","title":"Example 1: Defining Agents","text":"<p>Below is a concise example illustrating how to create an Agent with a specific role and goal.</p> <pre><code>from anote_agents import Agent\nsupport_bot = Agent(\nname=\"SupportBot\",\nrole=\"Technical Support\",\ngoal=\"Provide troubleshooting steps for user-reported issues\",\ninstructions=[\"Keep answers concise\", \"Include references where possible\"],\nverbose=True\n)\nprint(support_bot.role)\nprint(support_bot.goal)\n</code></pre>"},{"location":"api-qa/example2.html","title":"Example 2: Defining Tasks","text":"<p>Tasks detail what the Agent should do and what output is expected.</p> <pre><code>from anote_agents import Task\nfetch_inventory_task = Task(\ndescription=\"Fetch current inventory from the warehouse database\",\nexpected_output=\"A JSON object with product stock levels\",\nhuman_input=False,\nagent=None\n)\nprint(fetch_inventory_task.description)\n</code></pre>"},{"location":"api-qa/example3.html","title":"Example 3: Building Teams of Agents","text":"<p>Sometimes multiple Agents need to work together. Here\u2019s how you form a Crew.</p> <pre><code>from anote_agents import Agent, Crew, Task\nagent_web = Agent(name=\"WebAgent\", role=\"Research Data\")\nagent_fin = Agent(name=\"FinanceAgent\", role=\"Analyze Market Trends\")\ntask_research = Task(description=\"Research best stocks for Q4\", agent=agent_web)\ntask_analysis = Task(description=\"Perform financial analysis on the data\", agent=agent_fin)\nanalysis_crew = Crew(\nagents=[agent_web, agent_fin],\ntasks=[task_research, task_analysis],\nverbose=True\n)\nresults = analysis_crew.kickoff(inputs={\"sector\": \"Technology\"})\nprint(results)\n</code></pre>"},{"location":"api-qa/example4.html","title":"Example 4: Giving Agents Tools","text":"<p>Equip Agents with Tools to expand their capabilities.</p> <pre><code>from anote_agents import Agent\nfrom anote_agents.tools import SerperDevTool, ScrapeWebsiteTool\nsearch_tool = SerperDevTool()\nscrape_tool = ScrapeWebsiteTool()\nmarketing_agent = Agent(\nname=\"MarketingAgent\",\nrole=\"Marketing Research\",\ngoal=\"Research market trends and compile a summary\",\ntools=[search_tool],\nverbose=True\n)\n# Adding a second tool\nmarketing_agent.tools.append(scrape_tool)\n</code></pre>"},{"location":"api-qa/example5.html","title":"Example 5: Building Agentic Workflows","text":"<p>Demonstrates a multi-step process using multiple Agents and tasks.</p> <pre><code>from anote_agents import Agent, Task, Crew\nagent_planner = Agent(role=\"Planner\", goal=\"Outline the steps for an event\")\nagent_executor = Agent(role=\"Executor\", goal=\"Carry out the planned steps\")\nplan_task = Task(\ndescription=\"Create an event plan with {num_sessions} sessions\",\nagent=agent_planner\n)\nexecute_task = Task(\ndescription=\"Execute the event plan and provide final summary\",\nagent=agent_executor\n)\nworkflow_crew = Crew(\nagents=[agent_planner, agent_executor],\ntasks=[plan_task, execute_task],\nverbose=True\n)\n# Kick off\ninputs = {\"num_sessions\": 3}\nresults = workflow_crew.kickoff(inputs=inputs)\nprint(results)\n</code></pre>"},{"location":"api-qa/example6.html","title":"Chatting With Predefined Agents","text":"<p>Here we show how to initialize and communicate with an Agent that\u2019s already set up for a specific purpose.</p> <p>```python from anote_agents import Agent, Chat</p>"},{"location":"api-qa/example6.html#predefined-agent-eg-loaded-from-a-config-file-or-database","title":"Predefined Agent (e.g., loaded from a config file or database)","text":"<p>predefined_agent = Agent(     name=\"KnowledgeBaseAgent\",     role=\"Knowledge Base Assistant\",     goal=\"Answer technical questions from the internal knowledge base\" )</p>"},{"location":"api-qa/example6.html#create-a-chat-session","title":"Create a chat session","text":"<p>chat_id = Chat.create_session(agent=predefined_agent)</p>"},{"location":"api-qa/example6.html#example-query","title":"Example query","text":"<p>user_question = \"What is the recommended fix for error code 502?\" response = Chat.send_message(chat_id, user_question)</p> <p>print(\"Agent answer:\", response.answer) print(\"Sources:\", response.sources)</p>"},{"location":"api-usecase/usecase1.html","title":"Use Case: Financial Analysis","text":"<p>Use the SDK to gather real-time market data, analyze stock trends, and provide human-readable summaries.</p> <p>```python from anote_agents import Agent, Crew from anote_agents.tools import DuckDuckGo, YFinanceTools</p>"},{"location":"api-usecase/usecase1.html#web-research-agent","title":"Web research Agent","text":"<p>web_agent = Agent(     name=\"WebAgent\",     role=\"Search Market News\",     tools=[DuckDuckGo()],     instructions=[\"Always cite your sources\"] )</p>"},{"location":"api-usecase/usecase1.html#finance-data-agent","title":"Finance data Agent","text":"<p>finance_agent = Agent(     name=\"FinanceAgent\",     role=\"Analyze Stock Data\",     tools=[YFinanceTools(stock_price=True, analyst_recommendations=True, company_info=True)],     instructions=[\"Use tables where possible\"] )</p> <p>analysis_crew = Crew(     agents=[web_agent, finance_agent],     tasks=[],     verbose=True )</p>"},{"location":"api-usecase/usecase1.html#hypothetical-user-input","title":"Hypothetical user input","text":"<p>user_input = {     \"query\": \"Please analyze NVDA stock performance and summarize latest news.\" }</p> <p>result = analysis_crew.kickoff(inputs=user_input) print(\"Analysis result:\", result) Example Flow</p> <p>WebAgent retrieves relevant news articles (via DuckDuckGo). FinanceAgent fetches real-time stock data (via YFinanceTools). The Crew compiles the final summarized report.</p>"},{"location":"api-usecase/usecase2.html","title":"Use Case: Event Coordination","text":"<p>Coordinate and manage an event by assigning specialized tasks to different Agents.</p> <p>```python from anote_agents import Agent, Crew, Task from anote_agents.tools import SerperDevTool, ScrapeWebsiteTool</p> <p>search_tool = SerperDevTool() scrape_tool = ScrapeWebsiteTool()</p> <p>venue_coordinator = Agent(     role=\"Venue Coordinator\",     goal=\"Find and book a venue that meets event requirements\",     tools=[search_tool, scrape_tool],     verbose=True )</p> <p>logistics_manager = Agent(     role=\"Logistics Manager\",     goal=\"Handle catering, equipment, and attendee logistics\",     tools=[],     verbose=True )</p> <p>marketing_agent = Agent(     role=\"Marketing Agent\",     goal=\"Promote the event to potential attendees\",     tools=[search_tool],     verbose=True )</p> <p>venue_task = Task(     description=\"Find a venue in {event_city} for {expected_participants} participants.\",     expected_output=\"Venue details including cost, location, capacity.\",     agent=venue_coordinator )</p> <p>logistics_task = Task(     description=\"Organize catering and equipment for {expected_participants} participants.\",     expected_output=\"Menu options, equipment list, and cost breakdown.\",     agent=logistics_manager )</p> <p>marketing_task = Task(     description=\"Generate marketing strategy to attract {expected_participants} participants for the {event_topic}.\",     expected_output=\"A concise marketing plan including channels, budget, and timeline.\",     agent=marketing_agent )</p> <p>event_crew = Crew(     agents=[venue_coordinator, logistics_manager, marketing_agent],     tasks=[venue_task, logistics_task, marketing_task],     verbose=True )</p> <p>event_details = {     \"event_city\": \"Los Angeles\",     \"event_topic\": \"AI Conference\",     \"expected_participants\": 300 }</p> <p>result = event_crew.kickoff(inputs=event_details) print(result) Overview</p> <p>Each Agent handles a unique segment of event planning. The tasks can be executed in parallel or sequentially, depending on the workflow configuration.</p>"}]}